<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q5WR2KL8GJ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-Q5WR2KL8GJ');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POD Prompt & Image Generator</title>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Anton&family=Bangers&family=Cooper+Black&family=Inter:wght@400;500;600;700&family=Orbitron:wght@400..900&family=Press+Start+2P&display=swap"
        rel="stylesheet">

    <!-- Libraries for Doc Parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.5.1/mammoth.browser.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .orbitron {
            font-family: 'Orbitron', sans-serif;
        }

        .font-anton {
            font-family: 'Anton', sans-serif;
        }

        .font-cooper-black {
            font-family: 'Cooper Black', serif;
        }

        .font-bangers {
            font-family: 'Bangers', cursive;
        }

        .font-press-start {
            font-family: 'Press Start 2P', cursive;
        }

        .glass-effect {
            background: rgba(23, 23, 33, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .shimmer-gradient {
            background: linear-gradient(110deg, #1e1b4b 0%, #312e81 25%, #4f46e5 50%, #312e81 75%, #1e1b4b 100%);
            background-size: 200% 100%;
            animation: shimmer 5s linear infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-left-color: #6366f1;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        .small-loader {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-left-color: #fuchsia;
            /* Fuchsia for brainstorm */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 5px;
        }

        .research-loader {
            /* Cyan for research */
            border-left-color: #06b6d4;
            /* Cyan */
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #editor-canvas.editing {
            cursor: none;
        }

        /* Hide default cursor when editing */
        textarea:focus {
            outline: none;
        }

        #custom-cursor {
            position: fixed;
            /* FIXED: Use fixed position for viewport relativity */
            pointer-events: none;
            border-radius: 50%;
            border: 1px solid white;
            /* Thinner border */
            background-color: rgba(255, 255, 255, 0.3);
            /* Slightly more visible */
            transition: width 0.05s ease-out, height 0.05s ease-out;
            /* Faster transition */
            transform: translate(-50%, -50%);
            /* Center the cursor on the mouse pointer */
            display: none;
            /* Hidden by default, shown on canvas hover */
            z-index: 1000;
            /* Ensure it's on top */
        }

        /* Toggle switch styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4b5563;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #4f46e5;
        }

        input:checked+.slider:before {
            transform: translateX(22px);
        }

        #typography-options-container.disabled,
        .style-option-label.disabled,
        .typography-input:disabled {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }

        /* Tab Styles */
        .tab-button {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: border-color 0.3s ease, color 0.3s ease;
        }

        .tab-button.active {
            border-bottom-color: #6366f1;
            /* Indigo */
            color: #a5b4fc;
            /* Lighter Indigo */
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #brush-size-preview {
            /* Separate preview circle */
            border-radius: 50%;
            border: 1px dashed #a5b4fc;
            /* Lighter Indigo */
            background-color: rgba(99, 102, 241, 0.2);
            /* Indigo semi-transparent */
            transition: width 0.1s ease, height 0.1s ease;
            flex-shrink: 0;
            /* Prevent shrinking */
        }

        /* Filter slider styles */
        .filter-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4b5563;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }

        .filter-slider:hover {
            opacity: 1;
        }

        .filter-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #a5b4fc;
            cursor: pointer;
            border-radius: 50%;
        }

        .filter-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #a5b4fc;
            cursor: pointer;
            border-radius: 50%;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200 antialiased">
    <div id="custom-cursor"></div>
    <div class="min-h-screen w-full p-4 md:p-8 flex flex-col items-center">

        <header class="w-full max-w-4xl text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold orbitron text-indigo-400">POD Prompt & Image Generator</h1>
        </header>

        <div class="w-full max-w-4xl mb-6">
            <label for="imageUpload"
                class="w-full block py-3 px-4 text-lg text-center font-semibold text-white bg-gray-700 hover:bg-gray-600 rounded-lg shadow-lg cursor-pointer transition">
                Or Upload an Image to Edit & Describe
            </label>
            <input type="file" id="imageUpload" class="hidden" accept="image/*">
        </div>

        <main class="w-full max-w-4xl glass-effect rounded-2xl shadow-2xl p-6 md:p-8">
            <div id="main-generator-inputs" class="space-y-6">
                <div>
                    <label for="scenario" class="block text-sm font-medium text-gray-300 mb-2">1. User Scenario</label>
                    <div class="space-y-2 p-4 bg-gray-800/50 rounded-lg">
                        <div class="flex flex-col md:flex-row gap-2">
                            <input type="text" id="brainstorm-theme"
                                class="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-500"
                                placeholder="Enter a theme to get ideas (or upload a doc)">
                            <button id="brainstorm-btn"
                                class="py-3 px-5 font-semibold text-white bg-fuchsia-600 hover:bg-fuchsia-700 rounded-lg whitespace-nowrap">✨
                                Brainstorm Ideas</button>
                        </div>
                        <div class="flex items-center gap-4 mt-2">
                            <label for="upload-context-docs"
                                class="py-2 px-4 font-semibold text-white bg-gray-600 hover:bg-gray-700 rounded-lg cursor-pointer whitespace-nowrap">Upload
                                Context Docs</label>
                            <input type="file" id="upload-context-docs" class="hidden" accept=".txt,.json,.pdf,.docx">
                            <span id="context-doc-name" class="text-sm text-gray-400 italic">No file uploaded</span>
                        </div>
                        <div class="flex items-center mt-2">
                            <input type="checkbox" id="ai-search-context"
                                class="w-4 h-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500 mr-2">
                            <label for="ai-search-context" class="text-sm font-medium text-gray-300">Enable Live AI
                                Search for Context</label>
                        </div>
                        <div id="brainstorm-results" class="pt-2 flex flex-wrap gap-2"></div>
                        <div id="brainstorm-status" class="text-sm text-gray-400 mt-2"></div>
                    </div>
                    <div class="relative">
                        <textarea id="scenario" name="scenario" rows="3"
                            class="w-full mt-2 bg-gray-800 border border-gray-600 rounded-lg p-3 pr-10 text-white placeholder-gray-500 focus:ring-2 focus:ring-indigo-500"
                            placeholder="e.g., funny alien dancing on a farm, parody of Old MacDonald"></textarea>
                        <button id="copyScenarioBtn" class="absolute top-3 right-3 text-gray-400 hover:text-white"
                            title="Copy Scenario">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                viewBox="0 0 16 16">
                                <path
                                    d="M4 1.5H3a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-11a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-11a1 1 0 0 1 1-1h1v-1z" />
                                <path
                                    d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z" />
                            </svg>
                        </button>
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">2. Style Selector</label>
                    <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
                        <div class="relative"><input type="radio" id="style-auto" name="style" value="Auto"
                                class="peer sr-only"><label for="style-auto"
                                class="style-option-label flex items-center justify-center w-full p-3 text-center bg-gray-800 border border-indigo-500 rounded-lg cursor-pointer peer-checked:ring-2 peer-checked:ring-indigo-400 peer-checked:text-indigo-300 transition">✨
                                Auto</label></div>
                        <div class="relative"><input type="radio" id="style-cartoon" name="style"
                                value="bold cartoon graphic" class="peer sr-only style-option" checked><label
                                for="style-cartoon"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Cartoon</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-retro" name="style"
                                value="vintage retro graphic" class="peer sr-only style-option"><label for="style-retro"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Vintage</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-vaporwave" name="style"
                                value="vaporwave aesthetic" class="peer sr-only style-option"><label
                                for="style-vaporwave"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Vaporwave</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-scifi" name="style" value="sci-fi"
                                class="peer sr-only style-option"><label for="style-scifi"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Sci-Fi</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-minimalist" name="style"
                                value="minimalist vector" class="peer sr-only style-option"><label
                                for="style-minimalist"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Minimalist</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-psychedelic" name="style"
                                value="psychedelic groovy" class="peer sr-only style-option"><label
                                for="style-psychedelic"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Psychedelic</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-kawaii" name="style" value="kawaii chibi"
                                class="peer sr-only style-option"><label for="style-kawaii"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Kawaii</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-watercolor" name="style"
                                value="soft watercolor" class="peer sr-only style-option"><label for="style-watercolor"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Watercolor</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-cyberpunk" name="style"
                                value="cyberpunk neon" class="peer sr-only style-option"><label for="style-cyberpunk"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Cyberpunk</label>
                        </div>
                        <div class="relative"><input type="radio" id="style-deco" name="style" value="art deco"
                                class="peer sr-only style-option"><label for="style-deco"
                                class="style-option-label block w-full p-3 text-center bg-gray-800 border border-gray-600 rounded-lg cursor-pointer peer-checked:border-indigo-500 peer-checked:ring-2 peer-checked:ring-indigo-500 peer-checked:text-indigo-400 transition">Art
                                Deco</label></div>
                    </div>
                </div>

                <div>
                    <div class="flex items-center gap-4 mb-2">
                        <label class="block text-sm font-medium text-gray-300">3. Typography & Text Options</label>
                        <label for="toggle-typography" class="flex items-center cursor-pointer"
                            title="Enable/Disable all text options">
                            <input type="checkbox" id="toggle-typography" class="sr-only peer" checked>
                            <div
                                class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600">
                            </div>
                        </label>
                        <label for="auto-font-toggle" class="flex items-center cursor-pointer ml-auto"
                            title="Let AI choose the best font & text details">
                            <span class="mr-3 text-sm font-medium text-gray-300">✨ Auto-Select All Text</span>
                            <div class="relative">
                                <input type="checkbox" id="auto-font-toggle" class="sr-only peer">
                                <div
                                    class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600">
                                </div>
                            </div>
                        </label>
                    </div>
                    <div id="typography-options-container"
                        class="space-y-4 p-4 bg-gray-800/50 rounded-lg transition-opacity">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                                <label for="font-family" class="text-xs text-gray-400">Font Family</label>
                                <select id="font-family"
                                    class="typography-input w-full bg-gray-800 border border-gray-600 rounded-lg p-2.5 text-white focus:ring-2 focus:ring-indigo-500">
                                    <option value="Cooper Black" class="font-cooper-black">Cooper Black</option>
                                    <option value="Anton" class="font-anton">Anton</option>
                                    <option value="Bangers" class="font-bangers">Bangers</option>
                                    <option value="Orbitron" class="orbitron">Orbitron</option>
                                    <option value="Press Start 2P" class="font-press-start">Press Start 2P</option>
                                </select>
                            </div>
                            <div>
                                <label for="font-size" class="text-xs text-gray-400">Font Size</label>
                                <select id="font-size"
                                    class="typography-input w-full bg-gray-800 border border-gray-600 rounded-lg p-2.5 text-white focus:ring-2 focus:ring-indigo-500">
                                    <option value="tiny">Tiny</option>
                                    <option value="small">Small</option>
                                    <option value="normal" selected>Normal</option>
                                    <option value="large">Large</option>
                                    <option value="huge">Huge</option>
                                </select>
                            </div>
                            <div>
                                <label for="font-color" class="text-xs text-gray-400">Font Color</label>
                                <input type="color" id="font-color" value="#FFFFFF"
                                    class="typography-input w-full h-11 p-1 bg-gray-800 border border-gray-600 rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <div id="font-preview" class="p-2.5 rounded-lg bg-gray-900 text-center">Preview Text</div>
                        <div class="flex flex-col md:flex-row gap-2 items-center">
                            <input type="text" id="text-primary"
                                class="typography-input flex-grow w-full md:w-auto bg-gray-800 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-500"
                                placeholder="Primary Text">
                            <select id="pos-primary"
                                class="typography-input w-full md:w-48 bg-gray-800 border border-gray-600 rounded-lg p-3 text-white">
                                <option value="Top Arc" selected>Top Arc</option>
                                <option value="Middle">Middle</option>
                                <option value="Bottom Arc">Bottom Arc</option>
                            </select>
                        </div>
                        <div class="flex flex-col md:flex-row gap-2 items-center">
                            <input type="text" id="text-secondary"
                                class="typography-input flex-grow w-full md:w-auto bg-gray-800 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-500"
                                placeholder="Secondary Text">
                            <select id="pos-secondary"
                                class="typography-input w-full md:w-48 bg-gray-800 border border-gray-600 rounded-lg p-3 text-white">
                                <option value="Bottom Arc" selected>Bottom Arc</option>
                                <option value="Top Arc">Top Arc</option>
                                <option value="Middle">Middle</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">4. Export Options</label>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 p-4 bg-gray-800/50 rounded-lg">
                        <div>
                            <label for="file-type" class="text-xs text-gray-400">File Type</label>
                            <select id="file-type"
                                class="export-option w-full bg-gray-800 border border-gray-600 rounded-lg p-2.5 text-white">
                                <option value="Transparent PNG">Transparent PNG</option>
                                <option value="PNG (Opaque Background)">PNG (Opaque Background)</option>
                                <option value="JPEG">JPEG</option>
                                <option value="SVG">SVG</option>
                                <option value="TIFF">TIFF</option>
                            </select>
                        </div>
                        <div>
                            <label for="dimensions" class="text-xs text-gray-400">Dimensions</label>
                            <select id="dimensions"
                                class="export-option w-full bg-gray-800 border border-gray-600 rounded-lg p-2.5 text-white">
                                <option value="4500x5400 pixels (Apparel)">4500x5400px (Apparel)</option>
                                <option value="5000x5000 pixels (Square)">5000x5000px (Square)</option>
                                <option value="4800x3200 pixels (Landscape)">4800x3200px (Landscape)</option>
                                <option value="2700x2700 pixels (Mugs)">2700x2700px (Mugs)</option>
                                <option value="1200x2000 pixels (Phone Case)">1200x2000px (Phone Case)</option>
                                <option value="5400x7200 pixels (Poster 3:4)">5400x7200px (Poster 3:4)</option>
                            </select>
                        </div>
                        <div>
                            <label for="resolution" class="text-xs text-gray-400">Resolution</label>
                            <select id="resolution"
                                class="export-option w-full bg-gray-800 border border-gray-600 rounded-lg p-2.5 text-white">
                                <option value="300 DPI (Print)">300 DPI (Print)</option>
                                <option value="600 DPI (High-Detail)">600 DPI (High-Detail)</option>
                                <option value="150 DPI (Web)">150 DPI (Web)</option>
                                <option value="72 DPI (Screen)">72 DPI (Screen)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="flex items-center justify-end gap-4">
                    <label for="simple-prompt-toggle" class="flex items-center cursor-pointer">
                        <span class="mr-3 text-sm font-medium text-gray-300">Simple Prompt Mode</span>
                        <div class="relative">
                            <input type="checkbox" id="simple-prompt-toggle" class="sr-only peer">
                            <div
                                class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600">
                            </div>
                        </div>
                    </label>
                </div>

                <button id="generateBtn"
                    class="w-full py-3 px-4 text-lg font-semibold text-white shimmer-gradient rounded-lg shadow-lg hover:opacity-90 focus:outline-none focus:ring-4 focus:ring-indigo-500 transform hover:scale-105 duration-300">
                    Generate POD-Ready Prompt
                </button>
            </div>

            <div id="output-container" class="mt-8 border-t border-gray-700 pt-6 hidden">
                <div id="prompt-generator-section">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold text-gray-300">1. Image Generation Prompt (Editable)</h3>
                        <button id="copyPromptBtn"
                            class="text-sm bg-gray-700 hover:bg-indigo-600 text-white font-medium py-1 px-3 rounded-md transition">Copy</button>
                    </div>
                    <textarea id="prompt-output" rows="6"
                        class="w-full bg-gray-900/80 border border-gray-600 rounded-lg p-4 text-gray-300 whitespace-pre-wrap focus:ring-2 focus:ring-indigo-500"></textarea>
                    <div class="flex gap-4 my-6">
                        <button id="generateImageBtn"
                            class="w-full py-3 px-4 text-lg font-semibold text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg shadow-lg transform hover:scale-105">Generate
                            Image with Imagen</button>
                        <button id="generateNanoBtn"
                            class="w-full py-3 px-4 text-lg font-semibold text-white bg-purple-600 hover:bg-purple-700 rounded-lg shadow-lg transform hover:scale-105">Generate
                            with Nano-Banana</button>
                    </div>
                </div>

                <div id="image-preview-section" class="mb-6 hidden">
                    <h3 class="text-lg font-semibold text-gray-300 mb-2">Image Preview</h3>
                    <div
                        class="w-full min-h-[300px] bg-gray-900/80 border border-gray-600 rounded-lg p-4 flex flex-col items-center justify-center">
                        <div id="loader" class="loader hidden"></div>
                        <img id="generated-image" src="" alt="Generated image"
                            class="max-w-full max-h-96 rounded-lg hidden">
                        <p id="image-placeholder" class="text-gray-500">Image generation pending...</p>
                        <p id="error-message" class="text-red-400 hidden"></p>
                        <button id="downloadBtn1"
                            class="hidden mt-4 py-2 px-5 text-sm font-semibold text-white bg-green-600 hover:bg-green-700 rounded-lg shadow-md">Download
                            Image</button>
                    </div>
                </div>

                <div id="image-editor-section" class="mb-6 hidden">
                    <h3 class="text-lg font-semibold text-gray-300 mb-2">Image Editor (Inpainting)</h3>
                    <div class="space-y-4 p-4 bg-gray-800/50 rounded-lg">
                        <div class="flex items-center gap-4">
                            <label for="brush-size" class="text-sm">Brush Size:</label>
                            <input id="brush-size" type="range" min="5" max="100" value="30" class="flex-grow">
                            <div id="brush-size-preview" class="w-[30px] h-[30px]"></div>
                            <button id="resetEditBtn"
                                class="bg-gray-700 hover:bg-red-600 text-white font-medium py-1 px-3 rounded-md transition">Reset
                                Edits</button>
                            <button id="undoRegenBtn"
                                class="bg-gray-700 hover:bg-yellow-600 text-white font-medium py-1 px-3 rounded-md transition hidden">Undo
                                Regen</button>
                        </div>

                        {/* <!-- NEW: Filters Section --> */}
                        <div class="space-y-2 pt-4 border-t border-gray-700/50">
                            <label class="text-sm font-medium text-gray-300">Filters</label>
                            <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                                <div>
                                    <label for="brightness-slider" class="text-xs text-gray-400">Brightness (<span
                                            id="brightness-value">100</span>%)</label>
                                    <input type="range" id="brightness-slider" min="0" max="200" value="100"
                                        class="filter-slider">
                                </div>
                                <div>
                                    <label for="contrast-slider" class="text-xs text-gray-400">Contrast (<span
                                            id="contrast-value">100</span>%)</label>
                                    <input type="range" id="contrast-slider" min="0" max="200" value="100"
                                        class="filter-slider">
                                </div>
                                <div>
                                    <label for="saturation-slider" class="text-xs text-gray-400">Saturation (<span
                                            id="saturation-value">100</span>%)</label>
                                    <input type="range" id="saturation-slider" min="0" max="200" value="100"
                                        class="filter-slider">
                                </div>
                                <div>
                                    <button id="apply-filters-btn"
                                        class="w-full mt-4 py-2 px-4 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-lg">Apply
                                        Filters</button>
                                </div>
                            </div>
                        </div>

                        <canvas id="editor-canvas" class="w-full rounded-lg border border-gray-600"></canvas>
                        <textarea id="followup-prompt" rows="2"
                            class="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-500"
                            placeholder="Follow-up prompt (e.g., 'make the alien wear a purple hat')"></textarea>
                        <div class="flex gap-4">
                            <button id="regenerateImageBtn"
                                class="w-full py-3 px-4 text-lg font-semibold text-white bg-purple-600 hover:bg-purple-700 rounded-lg shadow-lg">Regenerate
                                with NanoBanana</button>
                            <button id="downloadBtn2"
                                class="w-full py-3 px-4 text-lg font-semibold text-white text-center bg-green-600 hover:bg-green-700 rounded-lg shadow-lg">Download
                                Edit</button>
                        </div>
                    </div>
                </div>

                <div id="description-generator-section" class="mb-6 hidden">
                    <h3 class="text-lg font-semibold text-gray-300 mb-2">AI Product Description Generator</h3>
                    <div class="space-y-4 p-4 bg-gray-800/50 rounded-lg">
                        <div class="space-y-2">
                            <label for="research-topic-input" class="text-sm font-medium text-gray-300">1. Research
                                SEO/GEO Topic</label>
                            <div class="flex items-center gap-2">
                                <input type="text" id="research-topic-input"
                                    class="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-500"
                                    placeholder="e.g., 3I/Atlas interstellar comet collection">
                                <button id="research-seo-btn"
                                    class="py-3 px-5 font-semibold text-white bg-cyan-600 hover:bg-cyan-700 rounded-lg whitespace-nowrap">Research
                                    SEO/GEO</button>
                            </div>
                            <div class="flex items-center mt-1">
                                <input type="checkbox" id="auto-populate-seo-topic"
                                    class="w-4 h-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500 mr-2">
                                <label for="auto-populate-seo-topic" class="text-xs font-medium text-gray-400">Auto-fill
                                    topic from Scenario</label>
                            </div>
                            <span id="research-status" class="text-sm text-gray-400 block mt-1"></span>
                        </div>
                        <div class="space-y-2">
                            <label for="research-profiles" class="text-sm font-medium text-gray-300">2. Load & Apply SEO
                                Research Profile</label>
                            <div class="flex gap-2">
                                <select id="research-profiles"
                                    class="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white">
                                    <option value="">Select a saved profile...</option>
                                </select>
                                <button id="save-profiles-btn"
                                    class="py-3 px-5 font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-lg"
                                    title="Save All Profiles to File">Save</button>
                                <label for="load-profiles-input"
                                    class="py-3 px-5 font-semibold text-white bg-gray-600 hover:bg-gray-700 rounded-lg cursor-pointer"
                                    title="Load Profiles from File">Load</label>
                                <input type="file" id="load-profiles-input" class="hidden" accept=".json">
                            </div>
                        </div>
                        <textarea id="image-context" rows="3"
                            class="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-500"
                            placeholder="AI will use this context. Load a profile, research a topic, or type keywords here."></textarea>
                        <input type="text" id="product-type"
                            class="w-full bg-gray-800 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-500"
                            placeholder="Enter product type (e.g., T-Shirt, Mug, Poster)">
                        <div class="flex flex-wrap gap-2">
                            <button id="generateDescBtn"
                                class="flex-1 py-2 px-4 font-semibold text-white bg-teal-600 hover:bg-teal-700 rounded-lg shadow-lg">Generate</button>
                            <button id="regenerateDescBtn"
                                class="flex-1 py-2 px-4 font-semibold text-white bg-sky-600 hover:bg-sky-700 rounded-lg shadow-lg">Regenerate</button>
                            <button id="toggle-source-btn"
                                class="flex-1 py-2 px-4 font-semibold text-white bg-gray-600 hover:bg-gray-700 rounded-lg shadow-lg"
                                title="Toggle HTML Source View">&lt;/&gt; Source</button>
                            <button id="copyDescBtn"
                                class="flex-1 py-2 px-4 font-semibold text-white bg-gray-600 hover:bg-gray-700 rounded-lg shadow-lg">Copy</button>
                        </div>
                        <div class="relative">
                            <div id="editor-toolbar"
                                class="hidden flex items-center gap-2 p-2 bg-gray-700/50 rounded-t-lg border-b border-gray-600">
                                <button class="edit-btn font-bold" data-tag="strong">B</button>
                                <button class="edit-btn italic" data-tag="em">I</button>
                                <button class="edit-btn underline" data-tag="u">U</button>
                                <button class="edit-btn" data-tag="mark">Highlight</button>
                                <button class="edit-btn" data-tag="span" data-style="font-size: 1.2em;">Enlarge</button>
                            </div>
                            <textarea id="description-output" rows="8"
                                class="w-full bg-gray-900/80 border border-gray-600 rounded-lg p-4 text-gray-300"
                                placeholder="Generated product description will appear here..."></textarea>
                            <div id="description-preview"
                                class="w-full min-h-[170px] bg-gray-900/80 border border-gray-600 rounded-lg p-4 text-gray-300 hidden prose prose-invert max-w-none">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="listing-generator-section" class="mb-6 hidden">
                    <h3 class="text-lg font-semibold text-gray-300 mb-2">5. Generate Platform-Specific Listings</h3>
                    <div class="space-y-4 p-4 bg-gray-800/50 rounded-lg">
                        <div>
                            <label for="platform-select" class="text-sm font-medium text-gray-300">Select
                                Platform</label>
                            <select id="platform-select"
                                class="w-full bg-gray-800 border border-gray-600 rounded-lg p-2.5 mt-1 text-white"></select>
                        </div>
                        <button id="auto-populate-listing-btn"
                            class="w-full py-2 px-4 text-sm font-semibold text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg shadow-lg">✨
                            Auto-Populate Inputs</button>
                        <div id="listing-inputs-container" class="space-y-2"></div>
                        <button id="generate-listing-btn"
                            class="w-full py-3 px-4 text-lg font-semibold text-white bg-green-600 hover:bg-green-700 rounded-lg shadow-lg">Generate
                            Listing</button>
                        <div id="listing-outputs-container" class="space-y-4 mt-4"></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Set worker for pdf.js
            if (window.pdfjsLib) {
                pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
            }

            // --- UI Element References ---
            const imageUploadInput = document.getElementById('imageUpload');
            const scenarioInput = document.getElementById('scenario');
            const copyScenarioBtn = document.getElementById('copyScenarioBtn');
            const brainstormThemeInput = document.getElementById('brainstorm-theme');
            const brainstormBtn = document.getElementById('brainstorm-btn');
            const brainstormResults = document.getElementById('brainstorm-results');
            const brainstormStatus = document.getElementById('brainstorm-status');
            const generateBtn = document.getElementById('generateBtn');
            const mainGeneratorInputs = document.getElementById('main-generator-inputs');
            const outputContainer = document.getElementById('output-container');
            const promptGeneratorSection = document.getElementById('prompt-generator-section');
            const promptOutput = document.getElementById('prompt-output');
            const copyPromptBtn = document.getElementById('copyPromptBtn');
            const generateImageBtn = document.getElementById('generateImageBtn');
            const generateNanoBtn = document.getElementById('generateNanoBtn');
            const imagePreviewSection = document.getElementById('image-preview-section');
            const loader = document.getElementById('loader');
            const generatedImage = document.getElementById('generated-image');
            const imagePlaceholder = document.getElementById('image-placeholder');
            const errorMessage = document.getElementById('error-message');
            const downloadBtn1 = document.getElementById('downloadBtn1');
            const downloadBtn2 = document.getElementById('downloadBtn2');
            const simplePromptToggle = document.getElementById('simple-prompt-toggle');

            // Font controls
            const toggleTypography = document.getElementById('toggle-typography');
            const typographyOptionsContainer = document.getElementById('typography-options-container');
            const autoFontToggle = document.getElementById('auto-font-toggle');
            const styleOptions = document.querySelectorAll('.style-option-label');
            const fontFamilySelect = document.getElementById('font-family');
            const fontSizeSelect = document.getElementById('font-size');
            const fontColorInput = document.getElementById('font-color');
            const fontPreview = document.getElementById('font-preview');
            const textPrimaryInput = document.getElementById('text-primary');
            const posPrimarySelect = document.getElementById('pos-primary');
            const textSecondaryInput = document.getElementById('text-secondary');
            const posSecondarySelect = document.getElementById('pos-secondary');


            // Editor elements
            const imageEditorSection = document.getElementById('image-editor-section');
            const editorCanvas = document.getElementById('editor-canvas');
            const ctx = editorCanvas.getContext('2d');
            const brushSizeInput = document.getElementById('brush-size');
            const brushSizePreview = document.getElementById('brush-size-preview');
            const customCursor = document.getElementById('custom-cursor');
            const clearMaskBtn = document.getElementById('resetEditBtn'); // Renamed
            const undoRegenBtn = document.getElementById('undoRegenBtn'); // New Undo Button
            const followupPromptInput = document.getElementById('followup-prompt');
            const regenerateImageBtn = document.getElementById('regenerateImageBtn');

            // --- NEW: Filter Elements ---
            const brightnessSlider = document.getElementById('brightness-slider');
            const contrastSlider = document.getElementById('contrast-slider');
            const saturationSlider = document.getElementById('saturation-slider');
            const brightnessValue = document.getElementById('brightness-value');
            const contrastValue = document.getElementById('contrast-value');
            const saturationValue = document.getElementById('saturation-value');
            const applyFiltersBtn = document.getElementById('apply-filters-btn');


            // Description Generator elements
            const descriptionGeneratorSection = document.getElementById('description-generator-section');
            const researchTopicInput = document.getElementById('research-topic-input');
            const researchSeoBtn = document.getElementById('research-seo-btn');
            const researchStatus = document.getElementById('research-status');
            const autoPopulateSeoTopicCheckbox = document.getElementById('auto-populate-seo-topic');
            const researchProfilesSelect = document.getElementById('research-profiles');
            const saveProfilesBtn = document.getElementById('save-profiles-btn');
            const loadProfilesInput = document.getElementById('load-profiles-input');
            const imageContextInput = document.getElementById('image-context');
            const productTypeInput = document.getElementById('product-type');
            const generateDescBtn = document.getElementById('generateDescBtn');
            const regenerateDescBtn = document.getElementById('regenerateDescBtn');
            const copyDescBtn = document.getElementById('copyDescBtn');
            const descriptionOutput = document.getElementById('description-output');
            const toggleSourceBtn = document.getElementById('toggle-source-btn');
            const descriptionPreview = document.getElementById('description-preview');
            const editorToolbar = document.getElementById('editor-toolbar');

            // New elements for context
            const uploadContextDocsInput = document.getElementById('upload-context-docs');
            const contextDocName = document.getElementById('context-doc-name');
            const aiSearchContextCheckbox = document.getElementById('ai-search-context');
            let uploadedContext = ''; // This will store structured JSON from the NLP agent

            // Listing Generator elements
            const listingGeneratorSection = document.getElementById('listing-generator-section');
            const platformSelect = document.getElementById('platform-select');
            const listingInputsContainer = document.getElementById('listing-inputs-container');
            const autoPopulateListingBtn = document.getElementById('auto-populate-listing-btn'); // New Button
            const generateListingBtn = document.getElementById('generate-listing-btn');
            const listingOutputsContainer = document.getElementById('listing-outputs-container');


            let originalImageBase64 = null;
            let previousImageBase64 = null; // For Undo
            let isDrawing = false;
            let isDescriptionSourceMode = false;
            let researchProfiles = {};
            let currentResearchData = null; // Store the most recent research result

            const FONT_SIZE_MAP = { tiny: '0.7rem', small: '0.85rem', normal: '1rem', large: '1.25rem', huge: '1.5rem' };

            // --- Core Logic ---

            const processUploadedContext = async (rawText) => {
                brainstormStatus.innerHTML = `Analyzing context with AI... <div class="small-loader"></div>`;
                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const prompt = `You are an NLP Task Agent. Analyze the following document text and extract key details. Return ONLY a valid JSON object with the keys: "main_themes" (array of strings), "key_entities" (array of strings), "visual_elements" (array of strings), and "summary" (a 1-2 sentence summary). Document: \n\n${rawText}`;

                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: 'OBJECT',
                            properties: {
                                main_themes: { type: 'ARRAY', items: { type: 'STRING' } },
                                key_entities: { type: 'ARRAY', items: { type: 'STRING' } },
                                visual_elements: { type: 'ARRAY', items: { type: 'STRING' } },
                                summary: { type: 'STRING' }
                            },
                            required: ['main_themes', 'key_entities', 'visual_elements', 'summary']
                        }
                    },
                    systemInstruction: {
                        parts: [{ text: "You are a helpful API that returns only valid JSON based on the user's request and provided schema." }]
                    }
                };

                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error((await response.json()).error?.message || 'AI analysis API call failed');
                    const result = await response.json();
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (jsonText && typeof jsonText === 'string') {
                        const contextData = JSON.parse(jsonText); // Parse it once
                        brainstormStatus.textContent = `✅ Context analyzed: ${contextData.summary}`;

                        // --- NEW LOGIC ---
                        // Auto-populate the theme input if it's empty
                        if (brainstormThemeInput.value.trim() === '') {
                            const derivedTheme = contextData.main_themes?.[0] || contextData.key_entities?.[0] || contextData.summary;
                            brainstormThemeInput.value = derivedTheme;
                            brainstormStatus.textContent += ` | Theme auto-populated.`;
                        }
                        // --- END NEW LOGIC ---

                        return jsonText; // Return the stringified JSON
                    } else {
                        throw new Error("API returned an empty or invalid response.");
                    }
                } catch (err) {
                    console.error("Error processing context:", err);
                    brainstormStatus.textContent = `Error: AI context analysis failed. ${err.message}`;
                    return null;
                }
            };

            const handleContextDocUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    uploadedContext = '';
                    contextDocName.textContent = 'No file uploaded';
                    return;
                }

                brainstormStatus.textContent = `Parsing "${file.name}"...`;
                contextDocName.textContent = file.name;
                uploadedContext = ''; // Reset context
                let rawText = '';

                try {
                    const reader = new FileReader();

                    if (file.type === 'application/pdf') {
                        reader.onload = async (e) => {
                            try {
                                const data = new Uint8Array(e.target.result);
                                // Initialize pdf.js worker
                                if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                                    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
                                }
                                const pdf = await pdfjsLib.getDocument({ data }).promise;
                                for (let i = 1; i <= pdf.numPages; i++) {
                                    const page = await pdf.getPage(i);
                                    const textContent = await page.getTextContent();
                                    rawText += textContent.items.map(item => item.str).join(' ') + '\n';
                                }
                                uploadedContext = await processUploadedContext(rawText); // Run NLP agent
                            } catch (pdfError) {
                                console.error("Error parsing PDF:", pdfError);
                                brainstormStatus.textContent = `Error parsing PDF. File may be corrupt or encrypted.`;
                            }
                        };
                        reader.readAsArrayBuffer(file);

                    } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                        reader.onload = async (e) => {
                            try {
                                const arrayBuffer = e.target.result;
                                const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                                rawText = result.value;
                                uploadedContext = await processUploadedContext(rawText); // Run NLP agent
                            } catch (docxError) {
                                console.error("Error parsing DOCX:", docxError);
                                brainstormStatus.textContent = `Error parsing DOCX file.`;
                            }
                        };
                        reader.readAsArrayBuffer(file);

                    } else if (file.type === 'text/plain' || file.type === 'application/json') {
                        reader.onload = async (e) => {
                            rawText = e.target.result;
                            uploadedContext = await processUploadedContext(rawText); // Run NLP agent
                        };
                        reader.readAsText(file);
                    } else {
                        throw new Error("Unsupported file type. Please upload .txt, .json, .pdf, or .docx");
                    }
                } catch (err) {
                    console.error("Error reading context file:", err);
                    uploadedContext = '';
                    contextDocName.textContent = 'Error reading file';
                    brainstormStatus.textContent = err.message;
                }
            };


            const handleTypographyToggle = () => {
                const isEnabled = toggleTypography.checked;
                typographyOptionsContainer.classList.toggle('disabled', !isEnabled);
                const inputs = typographyOptionsContainer.querySelectorAll('.typography-input, #auto-font-toggle'); // Use class + ID
                inputs.forEach(input => input.disabled = !isEnabled);

                // Re-enable the Auto toggle itself if typography is enabled, then check its state
                if (isEnabled) {
                    autoFontToggle.disabled = false;
                    handleAutoFontToggle(); // Apply auto font logic if needed
                }
            };

            const handleAutoFontToggle = () => {
                const isAutoFont = autoFontToggle.checked;
                // Disable all specific typography inputs if Auto is on
                const specificInputs = typographyOptionsContainer.querySelectorAll('.typography-input');
                specificInputs.forEach(input => {
                    input.disabled = isAutoFont;
                    // Add/remove a visual disabled style if needed, though parent opacity might cover it
                    input.classList.toggle('opacity-50', isAutoFont);
                    input.classList.toggle('cursor-not-allowed', isAutoFont);
                });
                // Ensure font preview reflects potential changes or gets disabled visual state
                fontPreview.classList.toggle('opacity-50', isAutoFont);
            };


            const handleAutoStyleSelect = () => {
                const isAutoStyle = document.getElementById('style-auto').checked;
                styleOptions.forEach(label => {
                    const inputId = label.getAttribute('for');
                    if (inputId !== 'style-auto') { // Target only non-auto labels/inputs
                        const inputElement = document.getElementById(inputId);
                        if (inputElement) {
                            inputElement.disabled = isAutoStyle; // Disable the radio button itself
                            label.classList.toggle('disabled', isAutoStyle); // Visually grey out the label
                        }
                    }
                });
            };

            const updateFontPreview = () => {
                if (autoFontToggle.checked) {
                    fontPreview.textContent = "Preview (AI Will Choose)";
                    return; // Don't try to preview if AI is choosing
                }
                const family = fontFamilySelect.value;
                const color = fontColorInput.value;
                const size = FONT_SIZE_MAP[fontSizeSelect.value];
                fontPreview.style.fontFamily = `"${family}", sans-serif`;
                fontPreview.style.color = color;
                fontPreview.style.fontSize = size;
                fontPreview.textContent = "Preview Text"; // Reset text content
                fontPreview.className = 'p-2.5 rounded-lg bg-gray-900 text-center'; // Reset classes
                if (family === 'Cooper Black') fontPreview.classList.add('font-cooper-black');
                else if (family === 'Anton') fontPreview.classList.add('font-anton');
                else if (family === 'Bangers') fontPreview.classList.add('font-bangers');
                else if (family === 'Orbitron') fontPreview.classList.add('orbitron');
                else if (family === 'Press Start 2P') fontPreview.classList.add('font-press-start');
            };

            const updateBrushSize = () => {
                const size = brushSizeInput.value;
                brushSizePreview.style.width = `${size}px`; // Update preview circle
                brushSizePreview.style.height = `${size}px`;
                customCursor.style.width = `${size}px`; // Update actual cursor
                customCursor.style.height = `${size}px`;
            };

            const getAIConfiguration = async (scenario) => {
                const styleRadio = document.querySelector('input[name="style"]:checked');
                let style = styleRadio ? styleRadio.value : 'bold cartoon graphic';
                const isAutoFont = autoFontToggle.checked;
                let fontConfig = { // Default structure
                    family: fontFamilySelect.value,
                    size: fontSizeSelect.value,
                    color: fontColorInput.value,
                    primary: { text: textPrimaryInput.value.trim(), pos: posPrimarySelect.value },
                    secondary: { text: textSecondaryInput.value.trim(), pos: posSecondarySelect.value }
                };

                if (style !== 'Auto' && !isAutoFont) {
                    return { style, fontConfig }; // Return current manual settings
                }

                const availableStyles = Array.from(document.querySelectorAll('input[name="style"]')).map(el => el.value).filter(v => v !== 'Auto');
                const availableFonts = Array.from(fontFamilySelect.options).map(opt => opt.value).filter(v => v !== 'Auto'); // Only non-auto fonts

                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                let prompt = `Act as a creative director specializing in POD design. Based on the design scenario "${scenario}", choose the following:\n`;
                if (style === 'Auto') {
                    prompt += `- style: Select the *single* most appropriate style from this list: [${availableStyles.join(', ')}]\n`;
                }
                if (isAutoFont) {
                    prompt += `- font: Select the *single* most appropriate font family from this list: [${availableFonts.join(', ')}] \n`;
                    prompt += `- primaryText: Suggest concise primary text (max 5 words) based on the scenario.\n`;
                    prompt += `- primaryPosition: Suggest the best position ('Top Arc', 'Middle', 'Bottom Arc') for the primary text.\n`;
                    prompt += `- secondaryText: Suggest concise secondary text (max 5 words) if appropriate, otherwise return an empty string.\n`;
                    prompt += `- secondaryPosition: Suggest the best position ('Top Arc', 'Middle', 'Bottom Arc') for the secondary text.\n`;
                    prompt += `- fontSize: Suggest a relative size ('tiny', 'small', 'normal', 'large', 'huge').\n`;
                    prompt += `- fontColor: Suggest a single appropriate hex color code (e.g., '#FFFFFF').\n`;
                }
                prompt += `\nReturn ONLY a single, valid JSON object containing keys ONLY for the items you were asked to select.
             Example for Style only: {"style": "vintage retro graphic"}
             Example for Font only: {"font": "Anton"}
             Example for Style and ALL Font details: {"style": "sci-fi", "font": "Orbitron", "primaryText": "Cosmic Beans", "primaryPosition": "Top Arc", "secondaryText": "Fuel Up", "secondaryPosition": "Bottom Arc", "fontSize": "large", "fontColor": "#A0FECB"}
             `;


                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error('AI config API call failed');
                    const result = await response.json();
                    // Add robust checking
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        const aiDecision = JSON.parse(jsonText);

                        // Merge AI decisions with existing manual settings
                        const finalStyle = style === 'Auto' ? aiDecision.style || style : style;
                        const finalFontConfig = {
                            family: isAutoFont ? aiDecision.font || fontConfig.family : fontConfig.family,
                            size: isAutoFont ? aiDecision.fontSize || fontConfig.size : fontConfig.size,
                            color: isAutoFont ? aiDecision.fontColor || fontConfig.color : fontConfig.color,
                            primary: {
                                text: isAutoFont ? aiDecision.primaryText || fontConfig.primary.text : fontConfig.primary.text,
                                pos: isAutoFont ? aiDecision.primaryPosition || fontConfig.primary.pos : fontConfig.primary.pos,
                            },
                            secondary: {
                                text: isAutoFont ? aiDecision.secondaryText || fontConfig.secondary.text : fontConfig.secondary.text,
                                pos: isAutoFont ? aiDecision.secondaryPosition || fontConfig.secondary.pos : fontConfig.secondary.pos,
                            }
                        };
                        return { style: finalStyle, fontConfig: finalFontConfig };

                    } else {
                        throw new Error("Invalid response structure from AI config API.");
                    }

                } catch (e) {
                    console.error("AI Configuration failed:", e);
                    // Fallback returns current manual settings if Auto fails
                    return {
                        style: style === 'Auto' ? 'bold cartoon graphic' : style,
                        fontConfig
                    };
                }
            };

            const buildSimplePrompt = (config) => {
                let prompt = `${config.style} artwork of ${config.scenario}.`;
                if (config.textConfig.enabled) {
                    const { primary, secondary, family } = config.textConfig; // FIXED: Destructured 'family' directly
                    // Only add typography if text content exists and position is valid
                    if ((primary.text && primary.pos !== 'none') || (secondary.text && secondary.pos !== 'none')) {
                        let typographyChunk = ` Typography uses '${family}' font.`; // FIXED: Used 'family' directly
                        if (primary.text && primary.pos !== 'none') typographyChunk += ` The phrase "${primary.text}" is at the ${primary.pos.toLowerCase().replace(' arc', '')}.`;
                        if (secondary.text && secondary.pos !== 'none') typographyChunk += ` The phrase "${secondary.text}" is at the ${secondary.pos.toLowerCase().replace(' arc', '')}.`;
                        prompt += typographyChunk;
                    }
                }
                const fileType = document.getElementById('file-type').value;
                prompt += ` Specifications: ${fileType.includes('Transparent') ? 'Transparent Background, ' : ''}${fileType}, ${document.getElementById('dimensions').value}, ${document.getElementById('resolution').value}.`;
                return prompt;
            };

            const buildPODReadyPrompt = (config) => {
                const chunks = [];
                chunks.push(`A ${config.style} print-on-demand artwork featuring ${config.scenario}.`);
                chunks.push(`Composition: single clear focal point, compact, centered, free-floating arrangement (avoid boxy look).`);
                chunks.push(`Palette: limited, high-contrast, 4-6 bold tones.`);
                chunks.push(`Details: thick, clean outline stroke on main subject and all text for visibility.`);

                if (config.textConfig.enabled) {
                    const { primary, secondary, size, color, family } = config.textConfig; // FIXED: Destructured all properties
                    // Only add typography if text content exists and position is valid
                    if ((primary.text && primary.pos !== 'none') || (secondary.text && secondary.pos !== 'none')) {
                        let typographyChunk = `Typography: Use a ${size}, bold '${family}' font with a dominant color of ${color}. The typography must be crisp, legible, and artistically integrated into the design. `; // FIXED: Used 'size', 'family', 'color' directly
                        if (primary.text && primary.pos !== 'none') typographyChunk += `The phrase "${primary.text}" is at the ${primary.pos.toLowerCase().replace(' arc', '')}. `;
                        if (secondary.text && secondary.pos !== 'none') typographyChunk += `The punchline "${secondary.text}" is at the ${secondary.pos.toLowerCase().replace(' arc', '')}, with emphasis.`;
                        chunks.push(typographyChunk);
                    }
                }
                const fileType = document.getElementById('file-type').value;
                chunks.push(`Export: print-ready, ${fileType.includes('Transparent') ? 'Transparent Background, ' : ''}${fileType}, ${document.getElementById('dimensions').value}, ${document.getElementById('resolution').value}.`);
                return chunks.join(' ');
            };

            const generatePrompt = async () => {
                const scenario = scenarioInput.value.trim();
                if (!scenario) return;

                generateBtn.disabled = true;
                generateBtn.textContent = 'Analyzing...';

                const aiConfigResult = await getAIConfiguration(scenario);

                // Update UI elements if AI made choices for typography
                if (autoFontToggle.checked) {
                    fontFamilySelect.value = aiConfigResult.fontConfig.family;
                    fontSizeSelect.value = aiConfigResult.fontConfig.size;
                    fontColorInput.value = aiConfigResult.fontConfig.color;
                    textPrimaryInput.value = aiConfigResult.fontConfig.primary.text;
                    posPrimarySelect.value = aiConfigResult.fontConfig.primary.pos;
                    textSecondaryInput.value = aiConfigResult.fontConfig.secondary.text;
                    posSecondarySelect.value = aiConfigResult.fontConfig.secondary.pos;
                    updateFontPreview(); // Update preview with AI choices
                }

                // Use the final config (potentially updated by AI) for prompt building
                const textConfig = {
                    enabled: toggleTypography.checked,
                    ...aiConfigResult.fontConfig // Spread the fontConfig which holds all text details
                };

                const promptConfig = {
                    scenario: scenario,
                    style: aiConfigResult.style, // Use the final style
                    textConfig,
                };

                if (simplePromptToggle.checked) {
                    promptOutput.value = buildSimplePrompt(promptConfig);
                } else {
                    promptOutput.value = buildPODReadyPrompt(promptConfig);
                }

                outputContainer.classList.remove('hidden');
                promptGeneratorSection.classList.remove('hidden');

                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate POD-Ready Prompt';
            };

            const callApiModel = async (url, payload, button, buttonText) => {
                // Centralized error handling and state management for API calls
                let originalButtonText = button.textContent;
                button.disabled = true;
                // Add a class for specific loaders if needed, default to small-loader
                const loaderClass = buttonText.startsWith('Research') ? 'small-loader research-loader' : 'small-loader';
                button.innerHTML = `<div class="${loaderClass}" style="margin-right: 5px;"></div> ${buttonText.split(' ')[0]}...`;

                if (loader && !buttonText.startsWith('Generate Desc') && !buttonText.startsWith('Research')) loader.classList.remove('hidden'); // Only show big loader for image generation
                if (generatedImage && !buttonText.startsWith('Generate Desc') && !buttonText.startsWith('Research')) [generatedImage, imagePlaceholder, errorMessage, downloadBtn1].forEach(el => el.classList.add('hidden'));

                try {
                    const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        let errorMsg = `HTTP error! status: ${response.status}`;
                        try {
                            const errorBody = await response.json();
                            errorMsg = errorBody.error?.message || errorMsg;
                        } catch (e) { /* Ignore parsing error if response isn't JSON */ }
                        throw new Error(errorMsg);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`API call failed for ${buttonText}:`, error);
                    if (errorMessage && !buttonText.startsWith('Generate Desc') && !buttonText.startsWith('Research')) {
                        errorMessage.textContent = `Error: ${error.message}`;
                        errorMessage.classList.remove('hidden');
                    }
                    if (imagePlaceholder && !buttonText.startsWith('Generate Desc') && !buttonText.startsWith('Research')) {
                        imagePlaceholder.textContent = 'Generation failed.';
                        imagePlaceholder.classList.remove('hidden');
                    }
                    // Handle description/research specific error display if needed
                    if (buttonText.startsWith('Generate Desc')) {
                        descriptionOutput.value = `Error: ${error.message}`;
                        descriptionPreview.innerHTML = `<p class="text-red-400">Error: ${error.message}</p>`;
                    }
                    if (buttonText.startsWith('Research')) {
                        researchStatus.textContent = `Error: ${error.message}`;
                        researchStatus.classList.add('text-red-400');
                    }

                    return null;
                } finally {
                    if (loader) loader.classList.add('hidden');
                    button.disabled = false;
                    button.textContent = buttonText; // Restore original button text
                }
            };

            const generateImageWithImagen = async () => {
                const currentPrompt = promptOutput.value;
                if (!currentPrompt) return;
                imagePreviewSection.classList.remove('hidden');
                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                const payload = { instances: [{ prompt: currentPrompt }], parameters: { "sampleCount": 1 } };
                const result = await callApiModel(apiUrl, payload, generateImageBtn, 'Generate Image with Imagen');
                if (result) {
                    const base64Data = result.predictions?.[0]?.bytesBase64Encoded;
                    if (base64Data) {
                        originalImageBase64 = `data:image/png;base64,${base64Data}`;
                        generatedImage.src = originalImageBase64;
                        generatedImage.classList.remove('hidden');
                        downloadBtn1.classList.remove('hidden'); // Show download button
                        downloadBtn2.href = originalImageBase64; // Also update edit download link initially
                        initializeEditor(originalImageBase64);
                        descriptionGeneratorSection.classList.remove('hidden');
                        listingGeneratorSection.classList.remove('hidden');
                    } else {
                        errorMessage.textContent = 'No image data in API response.';
                        errorMessage.classList.remove('hidden');
                    }
                }
            };

            const generateImageWithNanoBanana = async () => {
                const currentPrompt = promptOutput.value;
                if (!currentPrompt) return;
                imagePreviewSection.classList.remove('hidden');
                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                const payload = {
                    contents: [{ parts: [{ text: currentPrompt }] }],
                    generationConfig: { responseModalities: ['IMAGE'] },
                };
                const result = await callApiModel(apiUrl, payload, generateNanoBtn, 'Generate with Nano-Banana');
                if (result) {
                    const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                    if (base64Data) {
                        originalImageBase64 = `data:image/png;base64,${base64Data}`;
                        generatedImage.src = originalImageBase64;
                        generatedImage.classList.remove('hidden');
                        downloadBtn1.classList.remove('hidden'); // Show download button
                        downloadBtn2.href = originalImageBase64; // Also update edit download link initially
                        initializeEditor(originalImageBase64);
                        descriptionGeneratorSection.classList.remove('hidden');
                        listingGeneratorSection.classList.remove('hidden');
                    } else {
                        errorMessage.textContent = 'No image data in API response.';
                        errorMessage.classList.remove('hidden');
                    }
                }
            };

            const initializeEditor = (imageDataUrl) => {
                const img = new Image();
                img.onload = () => {
                    const aspectRatio = img.width / img.height;
                    editorCanvas.width = 512;
                    editorCanvas.height = 512 / aspectRatio;
                    ctx.drawImage(img, 0, 0, editorCanvas.width, editorCanvas.height);
                    imageEditorSection.classList.remove('hidden');
                    // Reset filters when a new image is loaded
                    resetFilters();
                };
                img.onerror = () => { // Basic error handling for image loading
                    console.error("Failed to load image onto canvas.");
                    // Optionally display an error message in the editor section
                };
                img.src = imageDataUrl;
            };

            const regenerateImage = async () => {
                const followupPrompt = followupPromptInput.value.trim();
                if (!followupPrompt || !originalImageBase64) return;

                // Store the state before regeneration for undo
                previousImageBase64 = originalImageBase64;
                undoRegenBtn.classList.remove('hidden'); // Show undo button

                // Apply filters *before* getting data for inpainting
                await applyFilters();

                imagePreviewSection.classList.remove('hidden');
                const maskBase64 = getMaskData();
                const imageBase64 = originalImageBase64.split(',')[1];
                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                const payload = {
                    contents: [{ parts: [{ text: followupPrompt }, { inlineData: { mimeType: "image/png", data: imageBase64 } }, { inlineData: { mimeType: "image/png", data: maskBase64 } }] }],
                    generationConfig: { responseModalities: ['IMAGE'] },
                };
                const result = await callApiModel(apiUrl, payload, regenerateImageBtn, 'Regenerate with NanoBanana');
                if (result) {
                    const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                    if (base64Data) {
                        originalImageBase64 = `data:image/png;base64,${base64Data}`;
                        generatedImage.src = originalImageBase64;
                        generatedImage.classList.remove('hidden');
                        downloadBtn1.classList.remove('hidden'); // Show download button
                        downloadBtn2.href = originalImageBase64; // Update edit download link
                        initializeEditor(originalImageBase64); // This will reload the canvas and reset filters
                    } else {
                        errorMessage.textContent = 'No image data in regeneration response.';
                        errorMessage.classList.remove('hidden');
                    }
                } else {
                    // If regeneration fails, roll back to the previous state
                    originalImageBase64 = previousImageBase64;
                    previousImageBase64 = null;
                    undoRegenBtn.classList.add('hidden');
                }
            };

            const handleUndoRegen = () => {
                if (!previousImageBase64) return;
                originalImageBase64 = previousImageBase64;
                previousImageBase64 = null;

                generatedImage.src = originalImageBase64; // Update main preview
                initializeEditor(originalImageBase64); // Reload editor
                downloadBtn2.href = originalImageBase64; // Reset download link
                undoRegenBtn.classList.add('hidden'); // Hide undo button
            };


            // --- NEW: Filter Logic ---
            const updateCanvasFilters = () => {
                const brightness = brightnessSlider.value;
                const contrast = contrastSlider.value;
                const saturation = saturationSlider.value;

                brightnessValue.textContent = brightness;
                contrastValue.textContent = contrast;
                saturationValue.textContent = saturation;

                editorCanvas.style.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
            };

            const resetFilters = () => {
                brightnessSlider.value = 100;
                contrastSlider.value = 100;
                saturationSlider.value = 100;
                updateCanvasFilters();
            };

            const applyFilters = () => {
                // This function now *bakes* the filter into the originalImageBase64
                // It's called before regeneration or can be called by the "Apply Filters" button
                const filterString = editorCanvas.style.filter;
                if (!originalImageBase64 || filterString === 'none' || filterString === '') return Promise.resolve(); // No filters to apply, return resolved promise

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const img = new Image();

                // We need to wait for the image to load before drawing, so we use a Promise
                return new Promise((resolve) => {
                    img.onload = () => {
                        tempCanvas.width = editorCanvas.width;
                        tempCanvas.height = editorCanvas.height;
                        tempCtx.filter = filterString;
                        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

                        originalImageBase64 = tempCanvas.toDataURL('image/png'); // Bake filters into the base image

                        // Redraw the main canvas with the new base image and reset CSS filters
                        resetFilters();
                        initializeEditor(originalImageBase64); // Reloads canvas with baked-in filters
                        resolve();
                    };
                    img.src = originalImageBase64; // Set src to trigger load
                });
            };


            const getLiveSearchContext = async (theme) => {
                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const prompt = `Provide a concise (1-2 sentence) summary of key concepts, recent news, or interesting facts related to the theme: "${theme}". Focus on information that would be inspiring for creating unique artwork.`;

                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    tools: [{ "google_search": {} }],
                };
                brainstormStatus.innerHTML = `Searching for context on "${theme}"... <div class="small-loader"></div>`;

                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        let errorMsg = `Live search failed: ${response.status}`;
                        try { errorMsg = (await response.json()).error?.message || errorMsg; } catch (e) { }
                        throw new Error(errorMsg);
                    }
                    const result = await response.json();
                    const contextText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    brainstormStatus.textContent = contextText ? `Found context: ${contextText.substring(0, 100)}...` : 'No context found.';
                    return contextText || '';
                } catch (error) {
                    console.error("Live search context fetch failed:", error);
                    brainstormStatus.textContent = `Error fetching context: ${error.message}`;
                    return ''; // Return empty string on failure
                }
            };


            const brainstormScenarios = async () => {
                const theme = brainstormThemeInput.value.trim();
                const contextJSON = uploadedContext; // This is a JSON string from the NLP agent
                const isLiveSearch = aiSearchContextCheckbox.checked;

                // --- FIXED GUARD CLAUSE ---
                if (!theme && !contextJSON) {
                    brainstormStatus.textContent = 'Please enter a theme or upload a context document to brainstorm.';
                    return;
                }

                brainstormStatus.textContent = ''; // Clear previous status
                brainstormResults.innerHTML = ''; // Clear previous results
                brainstormBtn.disabled = true;
                brainstormBtn.innerHTML = `Working... <div class="small-loader"></div>`;

                let contextForPrompt = '';
                let effectiveTheme = theme; // Prioritize typed theme

                // 1. Process Uploaded Context (if it exists)
                if (contextJSON) {
                    try {
                        const contextData = JSON.parse(contextJSON);
                        contextForPrompt += `User document context (analyzed): ${contextData.summary}\nKey Themes: ${contextData.main_themes.join(', ')}\nKey Visuals: ${contextData.visual_elements.join(', ')}\n`;

                        // If no theme was typed, derive one from the context
                        if (!effectiveTheme) {
                            effectiveTheme = contextData.main_themes?.[0] || contextData.key_entities?.[0] || 'the provided document';
                        }
                    } catch (e) {
                        console.error("Failed to parse context JSON:", e);
                        contextForPrompt += `User context (raw): ${contextJSON.substring(0, 300)}...\n`;
                        if (!effectiveTheme) {
                            effectiveTheme = 'the provided document';
                        }
                    }
                }

                // 2. Process Live Search (if checked AND we have a theme to search for)
                if (isLiveSearch && effectiveTheme) {
                    brainstormStatus.innerHTML = `Running live search for "${effectiveTheme}"... <div class="small-loader"></div>`;
                    const liveContext = await getLiveSearchContext(effectiveTheme);
                    if (liveContext) contextForPrompt += `Live search context: ${liveContext}\n`;
                } else if (isLiveSearch && !effectiveTheme) {
                    brainstormStatus.textContent = 'Please type a theme or upload a doc to enable live search.';
                }


                const style = document.querySelector('input[name="style"]:checked')?.value || 'bold cartoon graphic';
                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                let prompt = `You are a creative director for a trendy t-shirt company specializing in ${style} designs. Brainstorm 5 funny, clever, or visually interesting scenarios for print-on-demand artwork based on the theme: "${effectiveTheme}".`;
                if (contextForPrompt) {
                    prompt += `\n\n**IMPORTANT**: Synthesize and prioritize the following context when generating ideas:\n${contextForPrompt}`;
                }
                prompt += `\n\nReturn the result as ONLY a valid JSON array of 5 distinct strings. No other text, comments, or markdown formatting.`;


                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error((await response.json()).error?.message || `HTTP error! status: ${response.status}`);
                    const result = await response.json();
                    // Add robust checking
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        if (jsonText && typeof jsonText === 'string') {
                            const scenarios = JSON.parse(jsonText);
                            brainstormResults.innerHTML = '';
                            scenarios.forEach(s => {
                                const button = document.createElement('button');
                                button.textContent = s;
                                button.className = 'bg-gray-700 hover:bg-indigo-600 text-white text-sm font-medium py-1 px-3 rounded-full transition';
                                button.onclick = () => {
                                    scenarioInput.value = s;
                                    generatePrompt(); // Auto-generate the full prompt
                                };
                                brainstormResults.appendChild(button);
                            });
                            brainstormStatus.textContent = `Generated 5 ideas for "${effectiveTheme}" ${contextForPrompt ? 'using provided context.' : '.'}`;
                        } else {
                            throw new Error("API returned empty text in response.");
                        }
                    } else {
                        throw new Error("API returned an invalid response structure.");
                    }

                } catch (error) {
                    console.error("Brainstorming failed:", error);
                    brainstormStatus.textContent = `Error brainstorming: ${error.message}`;
                    brainstormResults.innerHTML = `<p class="text-red-400 text-sm">Could not generate ideas. Please try again.</p>`;
                } finally {
                    brainstormBtn.disabled = false;
                    brainstormBtn.textContent = '✨ Brainstorm Ideas';
                }
            };

            const researchSEOTopic = async () => {
                let topic = researchTopicInput.value.trim();
                if (autoPopulateSeoTopicCheckbox.checked) {
                    topic = scenarioInput.value.trim();
                    researchTopicInput.value = topic; // Update the input field as well
                }
                if (!topic) return;

                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const prompt = `You are a world-class SEO and Generative Engine Optimization (GEO) expert for e-commerce. A user wants to create products based on the topic: "${topic}". Conduct a web search to understand this topic's niche, audience, and related concepts. Return ONLY a valid JSON object with the following structure: {"topic": "string", "optimizedTitle": "string", "keywords": ["string"], "hashtags": ["string"], "descriptionHooks": ["string"], "geoInsights": "string"}. Keywords include long-tail variations. Hashtags for Instagram, Etsy, Pinterest. Hooks are compelling opening sentences. GeoInsights mention location relevance.`;

                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    tools: [{ "google_search": {} }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: 'OBJECT',
                            properties: {
                                topic: { type: 'STRING' },
                                optimizedTitle: { type: 'STRING' },
                                keywords: { type: 'ARRAY', items: { type: 'STRING' } },
                                hashtags: { type: 'ARRAY', items: { type: 'STRING' } },
                                descriptionHooks: { type: 'ARRAY', items: { type: 'STRING' } },
                                geoInsights: { type: 'STRING' }
                            },
                            required: ['topic', 'optimizedTitle', 'keywords', 'hashtags', 'descriptionHooks', 'geoInsights']
                        }
                    },
                    systemInstruction: {
                        parts: [{ text: "You are a helpful API that returns only valid JSON objects based on the user's request using the provided schema. Do not return any other text, explanations, or markdown." }]
                    }
                };

                researchStatus.textContent = `Researching "${topic}"...`;
                researchStatus.classList.remove('text-red-400', 'text-green-400');
                researchStatus.classList.add('text-gray-400');


                const result = await callApiModel(apiUrl, payload, researchSeoBtn, 'Research SEO/GEO'); // Updated Button Text

                if (result) {
                    // Defensive checks for the response structure
                    if (!result.candidates || !result.candidates[0] || !result.candidates[0].content || !result.candidates[0].content.parts || !result.candidates[0].content.parts[0] || !result.candidates[0].content.parts[0].text) {
                        researchStatus.textContent = "Error: API returned an invalid or empty response structure.";
                        researchStatus.classList.add('text-red-400');
                        return;
                    }

                    const jsonText = result.candidates[0].content.parts[0].text;

                    if (typeof jsonText !== 'string' || jsonText.trim() === '') {
                        researchStatus.textContent = "Error: API returned an empty text response.";
                        researchStatus.classList.add('text-red-400');
                        return;
                    }

                    try {
                        const researchData = JSON.parse(jsonText);

                        currentResearchData = researchData; // Store the latest research
                        researchProfiles[topic] = researchData;
                        updateResearchProfilesDropdown();
                        researchProfilesSelect.value = topic; // Auto-select the newly researched topic

                        // Populate context field
                        const keywords = researchData.keywords ? researchData.keywords.join(', ') : '';
                        const hooks = researchData.descriptionHooks ? researchData.descriptionHooks.join(' ') : '';
                        imageContextInput.value = `Keywords: ${keywords}\n\nHooks: ${hooks}`;

                        researchStatus.textContent = `✅ Research complete for "${topic}". Profile saved. Context populated.`;
                        researchStatus.classList.remove('text-red-400', 'text-gray-400');
                        researchStatus.classList.add('text-green-400');
                        setTimeout(() => { researchStatus.textContent = ''; }, 5000);


                    } catch (error) {
                        console.error("SEO Research failed during JSON parsing:", error);
                        let errorMessageText = `Error during research: ${error.message}`;
                        if (error instanceof SyntaxError) {
                            errorMessageText = "Error: API returned invalid JSON. Please try a different topic or wording.";
                        }
                        researchStatus.textContent = errorMessageText;
                        researchStatus.classList.add('text-red-400');
                    }
                } else {
                    // Error handled in callApiModel, update status if needed
                    if (!researchStatus.textContent.startsWith('Error:')) {
                        researchStatus.textContent = `Research failed for "${topic}". Check console for details.`;
                        researchStatus.classList.add('text-red-400');
                    }
                }
            };


            const generateDescription = async () => {
                const productType = productTypeInput.value.trim();
                const userContext = imageContextInput.value.trim();

                if (!productType || !originalImageBase64) {
                    descriptionOutput.value = "Please enter a product type and provide an image first.";
                    return;
                }

                const imageBase64 = originalImageBase64.split(',')[1];
                const apiKey = ""; // API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                let prompt = `Act as an expert eCommerce copywriter specializing in SEO and Generative Engine Optimization. Your task is to write a compelling product description for a ${productType}. Use the provided image as the primary visual reference. Identify the most salient SEO and GEO-relevant keywords in your response and wrap them in <strong> tags. For example: 'This is a great product for <strong>stargazers</strong> in <strong>California</strong>.'`;
                if (userContext) {
                    prompt += ` Crucially, you MUST incorporate the following user-provided context to inform the description's theme, keywords, and tone: "${userContext}".`;
                }
                prompt += ` Synthesize all information to create a rich, engaging, and SEO-optimized description of 2-3 paragraphs. Start with a catchy title. Do not mention product specs. The entire output should be valid HTML.`;

                const payload = { contents: [{ role: "user", parts: [{ text: prompt }, { inlineData: { mimeType: "image/png", data: imageBase64 } }] }] };

                generateDescBtn.disabled = true;
                regenerateDescBtn.disabled = true;
                generateDescBtn.textContent = 'Generating...';


                descriptionOutput.value = "";
                descriptionPreview.innerHTML = "<p>Generating creative product description...</p>";

                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error((await response.json()).error?.message || `HTTP error! status: ${response.status}`);
                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    descriptionOutput.value = text || "Could not generate a description from the response.";
                    descriptionPreview.innerHTML = descriptionOutput.value;

                    isDescriptionSourceMode = false;
                    editorToolbar.classList.add('hidden');
                    descriptionOutput.classList.add('hidden');
                    descriptionPreview.classList.remove('hidden');
                    toggleSourceBtn.textContent = '< />';
                    toggleSourceBtn.classList.remove('bg-indigo-600');
                    toggleSourceBtn.classList.add('bg-gray-600');

                } catch (error) {
                    console.error("Description generation failed:", error);
                    const errorMsg = `Error: ${error.message}`;
                    descriptionOutput.value = errorMsg;
                    descriptionPreview.innerHTML = `<p class="text-red-400">${errorMsg}</p>`;
                } finally {
                    generateDescBtn.disabled = false;
                    generateDescBtn.textContent = 'Generate';
                    regenerateDescBtn.disabled = false;
                }
            };

            const handleImageUpload = (event) => {
                const file = event.target.files[0];
                if (!file || !file.type.startsWith('image/')) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImageBase64 = e.target.result;
                    previousImageBase64 = null; // Clear undo state for new image
                    undoRegenBtn.classList.add('hidden');

                    generatedImage.src = originalImageBase64;
                    generatedImage.classList.remove('hidden');
                    imagePlaceholder.classList.add('hidden');
                    loader.classList.add('hidden');
                    errorMessage.classList.add('hidden');

                    mainGeneratorInputs.classList.add('hidden');
                    outputContainer.classList.remove('hidden');
                    promptGeneratorSection.classList.add('hidden');
                    imagePreviewSection.classList.remove('hidden');
                    descriptionGeneratorSection.classList.remove('hidden');
                    listingGeneratorSection.classList.remove('hidden');

                    downloadBtn1.classList.remove('hidden'); // Show download button

                    initializeEditor(originalImageBase64);
                };
                reader.readAsDataURL(file);
            };

            const toggleDescriptionView = () => {
                isDescriptionSourceMode = !isDescriptionSourceMode;
                if (isDescriptionSourceMode) {
                    // Show Source (Textarea)
                    descriptionPreview.classList.add('hidden');
                    descriptionOutput.classList.remove('hidden');
                    editorToolbar.classList.remove('hidden');
                    toggleSourceBtn.textContent = 'Preview';
                    toggleSourceBtn.classList.add('bg-indigo-600');
                    toggleSourceBtn.classList.remove('bg-gray-600');
                } else {
                    // Show Preview (Rendered HTML)
                    descriptionPreview.innerHTML = descriptionOutput.value; // Update preview from textarea
                    descriptionOutput.classList.add('hidden');
                    editorToolbar.classList.add('hidden');
                    descriptionPreview.classList.remove('hidden');
                    toggleSourceBtn.textContent = '< />';
                    toggleSourceBtn.classList.remove('bg-indigo-600');
                    toggleSourceBtn.classList.add('bg-gray-600');
                }
            };

            const wrapSelectionWithTag = (tag, style = '') => {
                const start = descriptionOutput.selectionStart;
                const end = descriptionOutput.selectionEnd;
                if (start === end) return; // No text selected

                const text = descriptionOutput.value;
                const selectedText = text.substring(start, end);

                let openTag = `<${tag}`;
                if (style) {
                    openTag += ` style="${style}"`;
                }
                openTag += '>';

                const closeTag = `</${tag}>`;

                const newText = `${text.substring(0, start)}${openTag}${selectedText}${closeTag}${text.substring(end)}`;
                descriptionOutput.value = newText;
            };

            const updateResearchProfilesDropdown = () => {
                researchProfilesSelect.innerHTML = '<option value="">Select a saved profile...</option>';
                for (const topic in researchProfiles) {
                    const option = document.createElement('option');
                    option.value = topic;
                    option.textContent = topic;
                    researchProfilesSelect.appendChild(option);
                }
            };

            const saveProfilesToFile = () => {
                if (Object.keys(researchProfiles).length === 0) return;
                const dataStr = JSON.stringify(researchProfiles, null, 2);
                const dataBlob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'vibe-code-research.json';
                link.click();
                URL.revokeObjectURL(url);
            };

            const loadProfilesFromFile = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedProfiles = JSON.parse(e.target.result);
                        researchProfiles = { ...researchProfiles, ...loadedProfiles }; // Merge with existing
                        updateResearchProfilesDropdown();
                    } catch (err) {
                        console.error("Error parsing profile file:", err);
                        alert("Invalid profile file format.");
                    }
                };
                reader.readAsText(file);
                event.target.value = null; // Reset input
            };

            // --- FIXED: Download Function ---
            const triggerDownload = (dataUrl, filename) => {
                if (!dataUrl) {
                    console.error("Download failed: No image data available.");
                    return;
                }
                fetch(dataUrl)
                    .then(res => res.blob())
                    .then(blob => {
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        window.URL.revokeObjectURL(url);
                    })
                    .catch(err => console.error("Error creating download blob:", err));
            };

            const getMaskData = () => {
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = editorCanvas.width;
                maskCanvas.height = editorCanvas.height;
                const maskCtx = maskCanvas.getContext('2d');
                maskCtx.drawImage(editorCanvas, 0, 0);
                const imageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i] === 255 && data[i + 1] === 0 && data[i + 2] === 255) { // Check for the pink mask color
                        data[i] = 255; data[i + 1] = 255; data[i + 2] = 255; data[i + 3] = 255; // White
                    } else {
                        data[i] = 0; data[i + 1] = 0; data[i + 2] = 0; data[i + 3] = 255; // Black
                    }
                }
                maskCtx.putImageData(imageData, 0, 0);
                return maskCanvas.toDataURL('image/png').split(',')[1];
            };
            const draw = (e) => {
                if (!isDrawing) return;
                e.preventDefault();
                const rect = editorCanvas.getBoundingClientRect();
                // Calculate coordinates relative to the canvas, accounting for page scroll
                const x = (e.clientX || e.touches[0].clientX) - rect.left;
                const y = (e.clientY || e.touches[0].clientY) - rect.top;

                const scaleX = editorCanvas.width / rect.width;
                const scaleY = editorCanvas.height / rect.height;
                ctx.fillStyle = 'rgba(255, 0, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(x * scaleX, y * scaleY, brushSizeInput.value * (scaleX), 0, Math.PI * 2);
                ctx.fill();
            };

            const POD_LISTING_TEMPLATES = {
                "_comment": "Master templates for Print-on-Demand (POD) product listings, optimized for SEO, GEO, and platform-specific requirements. Use placeholders like {{product_title}} and fill programmatically.",
                "etsy": {
                    "platform_name": "Etsy",
                    "best_practices": "Focus on long-tail, descriptive titles. Use all 13 tags. The first 160 characters of the description are critical for Google search results. Tell a story about the design.",
                    "validation": {
                        "title_char_limit": 140,
                        "tags_max_count": 13
                    },
                    "template": {
                        "title": "{{product_title}} | {{primary_keyword}}, {{secondary_keyword}}, {{geo_location}} Art, {{style_descriptor}}",
                        "description": "Dive into the world of {{theme}} with this stunning {{style_descriptor}} design. Featuring {{visual_element_1}} and {{visual_element_2}}, this artwork captures the essence of {{feeling_or_emotion}}. It's the perfect statement piece for any {{target_audience}} looking to express their passion for {{primary_keyword}}.\n\nThis piece, titled '{{product_title}}', is more than just a design; it's a conversation starter. Whether you're in {{geo_location}} or across the globe, it's a unique way to showcase your style. Made with care and printed on demand, you're receiving a piece of art made just for you.\n\nThank you for supporting independent artists!",
                        "tags": "{{primary_keyword}}, {{secondary_keyword}}, {{geo_location}}Art, {{style_descriptor}}, {{target_audience}}Gift, {{theme}}, {{visual_element_1}}, {{visual_element_2}}, {{color_1}}, {{color_2}}, IndieArt, POD, CustomDesign"
                    }
                },
                "amazon_seller": {
                    "platform_name": "Amazon Seller Central",
                    "best_practices": "Title must be keyword-rich and follow brand guidelines. Bullet points are the most critical selling feature; focus on benefits. Use backend search terms to capture related queries without cluttering the listing.",
                    "validation": {
                        "title_char_limit": 200,
                        "bullet_points_max_count": 5,
                        "description_char_limit": 2000,
                        "search_terms_bytes_limit": 250
                    },
                    "template": {
                        "title": "[Your Brand Name] {{product_title}} - {{primary_keyword}} Artwork for {{product_type}} - {{style_descriptor}} Design",
                        "bullet_points": [
                            "UNIQUE ARTWORK: Features an exclusive, high-detail design inspired by {{theme}}, perfect for expressing your personal style.",
                            "VIBRANT & DURABLE PRINT: Using advanced printing technology, the {{style_descriptor}} colors are made to last without fading.",
                            "GREAT GIFT IDEA: The perfect gift for any {{target_audience}} on birthdays, holidays, or special occasions. A unique present for fans of {{secondary_keyword}}.",
                            "PREMIUM QUALITY: Made from high-quality materials to ensure comfort and durability (for apparel) or lasting quality (for other goods).",
                            "DESIGNED FOR FANS: Whether you're from {{geo_location}} or just love the vibe, this {{primary_keyword}} design is a must-have for your collection."
                        ],
                        "description": "Discover the perfect fusion of art and style with our '{{product_title}}' design. This piece was created for the passionate {{target_audience}} who appreciates {{style_descriptor}} aesthetics and unique artwork. The design features a stunning depiction of {{visual_element_1}} and {{visual_element_2}}, capturing the core of {{theme}}. It’s an ideal way to add a touch of personality to your wardrobe or home. All our products are printed on-demand with meticulous attention to detail, ensuring you receive a premium-quality item you'll love. [Your Brand Name] is dedicated to bringing independent art to the world. Add this piece to your cart today!",
                        "backend_search_terms": "{{primary_keyword}}, {{secondary_keyword}}, {{theme}}, {{style_descriptor}}, {{target_audience}}, {{geo_location}}"
                    }
                },
                "instagram_shop": {
                    "platform_name": "Instagram Shop",
                    "best_practices": "Descriptions should be mobile-first and conversational. Use emojis and line breaks to improve readability. Hashtags are crucial for discovery within the app.",
                    "validation": {
                        "description_char_limit": 2200,
                        "hashtags_max_count": 30
                    },
                    "template": {
                        "description": "Presenting '{{product_title}}' ✨\n\nA fresh design inspired by the vibes of {{theme}} and {{feeling_or_emotion}}.\n\n🔹 Unique {{style_descriptor}} artwork\n🔹 Features {{visual_element_1}} & {{visual_element_2}}\n🔹 Perfect for any {{target_audience}}\n\nTap the link in our bio to shop the full collection! 🛍️\n\n#{{primary_keyword}} #{{secondary_keyword}} #{{style_descriptor}} #{{theme}} #{{geo_location}} #IndieArtist #PrintOnDemand #ShopSmall #ArtForSale #YourBrandHashtag"
                    }
                },
                "tiktok_shop": {
                    "platform_name": "TikTok Shop",
                    "validation": { "product_name_char_limit": 100, "description_char_limit": 1000 },
                    "template": {
                        "product_name": "{{product_title}} - {{style_descriptor}} {{product_type}}",
                        "description": "Check out our new '{{product_title}}' design! 👇\n\n- 🔥 Unique {{style_descriptor}} art\n- 🎨 Inspired by {{theme}}\n- 🎁 Perfect gift for {{target_audience}}\n\nGet yours now before it's gone! Link in video.\n\n#TikTokShop #{{primary_keyword}} #{{theme}} #GiftIdeas #Art #Design #fyp"
                    }
                },
                "pinterest": {
                    "platform_name": "Pinterest",
                    "validation": { "title_char_limit": 100, "description_char_limit": 500 },
                    "template": {
                        "title": "{{product_title}} - A {{style_descriptor}} design for {{target_audience}}",
                        "description": "Find your next obsession with this {{style_descriptor}} artwork inspired by {{theme}}. This {{primary_keyword}} design is perfect for adding a unique touch to your style or home decor. Ideal for anyone who loves {{secondary_keyword}} and appreciates detailed, independent art from {{geo_location}}. Explore more unique gift ideas and creative inspiration on our board."
                    }
                },
                "redbubble_teepublic": {
                    "platform_name": "Redbubble / TeePublic",
                    "validation": { "tags_min_count": 15 },
                    "template": {
                        "title": "{{product_title}}",
                        "description": "A design for all the {{target_audience}} out there. This piece, '{{product_title}}', was inspired by my love for {{theme}} and the aesthetics of {{style_descriptor}} art. It features {{visual_element_1}} and a hint of {{visual_element_2}}, created to evoke a feeling of {{feeling_or_emotion}}. Perfect for anyone who is a fan of {{primary_keyword}} or is looking for a unique piece of wearable art.",
                        "tags": "{{primary_keyword}}, {{secondary_keyword}}, {{theme}}, {{style_descriptor}}, {{target_audience}}, {{geo_location}}, {{visual_element_1}}, {{visual_element_2}}, {{feeling_or_emotion}}, {{color_1}}, {{color_2}}, illustration, graphic design, vector art, funny, cute, cool"
                    }
                },
                "printify_master": {
                    "platform_name": "Printify (Master Template)",
                    "validation": { "title_char_limit": 120 },
                    "template": {
                        "title": "{{product_title}} - {{style_descriptor}} {{primary_keyword}} Design",
                        "description": "Express yourself with our unique '{{product_title}}' artwork, a must-have for any {{target_audience}}. This {{style_descriptor}} design is inspired by {{theme}} and features a stunning visual of {{visual_element_1}}.\n\nKey Features:\n• High-quality, durable print\n• Unique design by an independent artist\n• Perfect gift for fans of {{secondary_keyword}}\n\nWhether you're looking for a statement piece or the perfect gift, this design is sure to impress. Printed on-demand on premium products to ensure you get the best quality. Order yours today!"
                    }
                }
            };

            const populatePlatformSelector = () => {
                platformSelect.innerHTML = '<option value="">Select a platform...</option>';
                for (const key in POD_LISTING_TEMPLATES) {
                    if (key === "_comment") continue;
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = POD_LISTING_TEMPLATES[key].platform_name;
                    platformSelect.appendChild(option);
                }
            };

            const getRequiredPlaceholders = (templateObject) => {
                const placeholders = new Set();
                const regex = /\{\{([a-zA-Z0-9_]+)\}\}/g;

                function findPlaceholders(obj) {
                    for (const key in obj) {
                        if (typeof obj[key] === 'string') {
                            let match;
                            while ((match = regex.exec(obj[key])) !== null) {
                                placeholders.add(match[1]);
                            }
                        } else if (Array.isArray(obj[key])) {
                            obj[key].forEach(item => {
                                if (typeof item === 'string') {
                                    let match;
                                    while ((match = regex.exec(item)) !== null) {
                                        placeholders.add(match[1]);
                                    }
                                }
                            });
                        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                            findPlaceholders(obj[key]);
                        }
                    }
                }
                findPlaceholders(templateObject);
                return Array.from(placeholders);
            };

            const displayListingInputs = () => {
                const platformKey = platformSelect.value;
                listingInputsContainer.innerHTML = '';
                listingOutputsContainer.innerHTML = '';
                if (!platformKey) return;

                const template = POD_LISTING_TEMPLATES[platformKey].template;
                const placeholders = getRequiredPlaceholders(template);

                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';

                placeholders.forEach(ph => {
                    const label = document.createElement('label');
                    label.textContent = ph.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    label.className = 'block text-sm font-medium text-gray-300';

                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `listing-input-${ph}`;
                    input.name = ph;
                    input.className = 'w-full bg-gray-800 border border-gray-600 rounded-lg p-2 mt-1 text-white';

                    const container = document.createElement('div');
                    container.appendChild(label);
                    container.appendChild(input);
                    grid.appendChild(container);
                });
                listingInputsContainer.appendChild(grid);
            };

            const autoPopulateListingInputs = () => {
                const platformKey = platformSelect.value;
                const selectedTopic = researchProfilesSelect.value;
                const profile = currentResearchData || researchProfiles[selectedTopic]; // Prioritize most recent research
                const currentScenario = scenarioInput.value;
                const currentDescription = descriptionOutput.value;
                const selectedStyle = document.querySelector('input[name="style"]:checked')?.value || '';
                const currentProductType = productTypeInput.value;

                if (!platformKey) return; // Need a platform selected

                const placeholders = getRequiredPlaceholders(POD_LISTING_TEMPLATES[platformKey].template);

                placeholders.forEach(ph => {
                    const inputElement = document.getElementById(`listing-input-${ph}`);
                    if (!inputElement) return; // Skip if input doesn't exist for this placeholder

                    let valueToPopulate = '';

                    // Mapping logic - prioritize profile, then description, then scenario
                    switch (ph) {
                        case 'product_title':
                            valueToPopulate = profile?.optimizedTitle || currentScenario.substring(0, 50) || 'My Awesome Design';
                            break;
                        case 'primary_keyword':
                            valueToPopulate = profile?.keywords?.[0] || '';
                            break;
                        case 'secondary_keyword':
                            valueToPopulate = profile?.keywords?.[1] || '';
                            break;
                        case 'geo_location':
                            valueToPopulate = profile?.geoInsights || '';
                            break;
                        case 'style_descriptor':
                            valueToPopulate = selectedStyle !== 'Auto' ? selectedStyle : (profile?.style_descriptor || 'Unique Style'); // Add fallback if Auto fails or not used
                            break;
                        case 'theme':
                            valueToPopulate = profile?.topic || researchTopicInput.value || ''; // Use research topic if available
                            break;
                        case 'product_type':
                            valueToPopulate = currentProductType || 'Apparel';
                            break;
                        // Try simple extraction (less reliable, might need refinement)
                        case 'visual_element_1':
                        case 'visual_element_2':
                        case 'feeling_or_emotion':
                        case 'target_audience':
                        case 'color_1':
                        case 'color_2':
                            // Attempt extraction from scenario/description or use profile data if keys exist
                            const profileKeywords = profile?.keywords || [];
                            if (ph === 'visual_element_1' && profileKeywords.length > 2) valueToPopulate = profileKeywords[2];
                            else if (ph === 'visual_element_2' && profileKeywords.length > 3) valueToPopulate = profileKeywords[3];
                            else if (ph === 'target_audience' && profileKeywords.length > 4) valueToPopulate = profileKeywords[4];
                            else valueToPopulate = ''; // Default to blank for less critical/harder-to-extract fields
                            break;
                        default:
                            valueToPopulate = ''; // Default for unmapped placeholders
                    }

                    inputElement.value = valueToPopulate;
                });
            };


            const generateListing = () => {
                const platformKey = platformSelect.value;
                if (!platformKey) return;

                const template = POD_LISTING_TEMPLATES[platformKey].template;
                const validation = POD_LISTING_TEMPLATES[platformKey].validation || {}; // Ensure validation object exists
                const placeholders = getRequiredPlaceholders(template);

                const data = {};
                placeholders.forEach(ph => {
                    const inputElement = document.getElementById(`listing-input-${ph}`);
                    data[ph] = inputElement ? inputElement.value : ''; // Handle missing input elements gracefully
                });

                listingOutputsContainer.innerHTML = '';

                for (const key in template) {
                    let content = Array.isArray(template[key]) ? template[key] : [template[key]];
                    let finalContent = content.map(item => {
                        let replacedItem = item;
                        for (const ph in data) {
                            replacedItem = replacedItem.replace(new RegExp(`\\{\\{${ph}\\}\\}`, 'g'), data[ph]);
                        }
                        return replacedItem;
                    });

                    if (key === 'bullet_points') {
                        listingOutputsContainer.innerHTML += `<h4 class="text-md font-semibold text-gray-300 mt-4">Bullet Points</h4>`;
                        finalContent.forEach((bullet, index) => {
                            createOutputField(`bullet_${index + 1}`, `Bullet Point ${index + 1}`, bullet, validation, key);
                        });
                    } else {
                        createOutputField(key, key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()), finalContent.join('\n'), validation, key);
                    }
                }
            };

            const createOutputField = (id, label, value, validation, key) => {
                const container = document.createElement('div');
                container.className = 'relative';

                const labelEl = document.createElement('label');
                labelEl.setAttribute('for', `output-${id}`);
                labelEl.className = 'block text-sm font-medium text-gray-300 mb-1';
                labelEl.textContent = label;

                const textarea = document.createElement('textarea');
                textarea.id = `output-${id}`;
                textarea.value = value;
                textarea.rows = id.includes('bullet') ? 2 : (key === 'tags' ? 3 : 5);
                textarea.className = 'w-full bg-gray-900/80 border border-gray-600 rounded-lg p-3 pr-10 text-gray-300';

                const copyBtn = document.createElement('button');
                copyBtn.className = 'absolute top-8 right-3 text-gray-400 hover:text-white';
                copyBtn.title = `Copy ${label}`;
                copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-11a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-11a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg>`;
                copyBtn.onclick = () => {
                    const originalIcon = copyBtn.innerHTML;
                    navigator.clipboard.writeText(textarea.value).then(() => {
                        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-green-400" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/></svg>`;
                        setTimeout(() => { copyBtn.innerHTML = originalIcon; }, 2000);
                    }, (err) => {
                        console.error('Async: Could not copy text: ', err);
                        // Fallback for environments where clipboard API might fail (like certain iframes)
                        const fallbackTextArea = document.createElement('textarea');
                        fallbackTextArea.value = textarea.value;
                        document.body.appendChild(fallbackTextArea);
                        fallbackTextArea.select();
                        try {
                            document.execCommand('copy');
                            copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-green-400" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/></svg>`;
                        } catch (execErr) {
                            console.error('Fallback copy failed', execErr);
                            copyBtn.innerHTML = 'Fail';
                        }
                        document.body.removeChild(fallbackTextArea);
                        setTimeout(() => { copyBtn.innerHTML = originalIcon; }, 2000);

                    });
                };

                const validationEl = document.createElement('div');
                validationEl.className = 'text-xs text-gray-500 text-right mt-1';
                const charLimit = validation[`${key}_char_limit`];
                const maxCount = validation[`${key}_max_count`];
                const minCount = validation[`${key}_min_count`];
                const bytesLimit = validation[`${key}_bytes_limit`];

                let currentCount = 0;
                let countLabel = '';

                if (key === 'tags') {
                    currentCount = value.split(',').map(tag => tag.trim()).filter(tag => tag).length;
                    countLabel = 'tags';
                } else if (key === 'bullet_points' && Array.isArray(content)) {
                    currentCount = content.length; // Count generated bullets
                    countLabel = 'bullets';
                } else if (key === 'backend_search_terms') {
                    currentCount = new TextEncoder().encode(value).length;
                    countLabel = 'bytes';
                }
                else {
                    currentCount = value.length;
                    countLabel = 'chars';
                }

                let validationText = '';
                let isInvalid = false;

                if (charLimit) {
                    validationText += `${currentCount} / ${charLimit} chars`;
                    if (currentCount > charLimit) isInvalid = true;
                } else if (maxCount) {
                    validationText += `${currentCount} / ${maxCount} ${countLabel}`;
                    if (currentCount > maxCount) isInvalid = true;
                } else if (minCount) {
                    validationText += `${currentCount} (min ${minCount}) ${countLabel}`;
                    if (currentCount < minCount) isInvalid = true;
                } else if (bytesLimit) {
                    validationText += `${currentCount} / ${bytesLimit} bytes`;
                    if (currentCount > bytesLimit) isInvalid = true;
                }

                if (validationText) {
                    validationEl.textContent = validationText;
                    if (isInvalid) {
                        validationEl.classList.remove('text-gray-500');
                        validationEl.classList.add('text-red-500');
                    }
                }


                container.appendChild(labelEl);
                container.appendChild(textarea);
                container.appendChild(copyBtn);
                if (validationText) container.appendChild(validationEl); // Only add if validation exists

                listingOutputsContainer.appendChild(container);
            };
            // --- RESTORED/FIXED LOGIC BLOCK ENDS HERE ---


            // --- Event Listeners ---
            imageUploadInput.addEventListener('change', handleImageUpload);
            generateBtn.addEventListener('click', generatePrompt);
            brainstormBtn.addEventListener('click', brainstormScenarios);
            generateImageBtn.addEventListener('click', generateImageWithImagen);
            generateNanoBtn.addEventListener('click', generateImageWithNanoBanana);
            regenerateImageBtn.addEventListener('click', regenerateImage);
            undoRegenBtn.addEventListener('click', handleUndoRegen); // New Listener
            generateDescBtn.addEventListener('click', generateDescription);
            regenerateDescBtn.addEventListener('click', generateDescription);
            copyDescBtn.addEventListener('click', () => {
                const textToCopy = descriptionOutput.value;
                if (!textToCopy) return;

                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                textArea.style.position = 'fixed';
                textArea.style.top = '-9999px';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    copyDescBtn.textContent = 'Copied!';
                    setTimeout(() => { copyDescBtn.textContent = 'Copy'; }, 2000);
                } catch (err) {
                    console.error('Copy description failed', err);
                    copyDescBtn.textContent = 'Failed!';
                    setTimeout(() => { copyDescBtn.textContent = 'Copy'; }, 2000);
                }
                document.body.removeChild(textArea);
            });

            copyScenarioBtn.addEventListener('click', () => {
                const textToCopy = scenarioInput.value;
                if (!textToCopy) return;
                const originalIcon = copyScenarioBtn.innerHTML;
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    copyScenarioBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-green-400" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/></svg>`;
                    setTimeout(() => { copyScenarioBtn.innerHTML = originalIcon; }, 2000);
                } catch (err) {
                    console.error('Copy scenario failed', err);
                }
                document.body.removeChild(textArea);
            });

            toggleSourceBtn.addEventListener('click', toggleDescriptionView);
            toggleTypography.addEventListener('change', handleTypographyToggle);
            autoFontToggle.addEventListener('change', handleAutoFontToggle); // Listener for Auto Font
            document.querySelectorAll('input[name="style"]').forEach(radio => {
                radio.addEventListener('change', handleAutoStyleSelect); // Listener for Auto Style
            });

            saveProfilesBtn.addEventListener('click', saveProfilesToFile);
            loadProfilesInput.addEventListener('change', loadProfilesFromFile);
            uploadContextDocsInput.addEventListener('change', handleContextDocUpload);
            autoPopulateListingBtn.addEventListener('click', autoPopulateListingInputs); // Listener for Auto Populate

            // Auto-populate SEO topic from scenario
            autoPopulateSeoTopicCheckbox.addEventListener('change', () => {
                if (autoPopulateSeoTopicCheckbox.checked) {
                    researchTopicInput.value = scenarioInput.value;
                }
            });
            scenarioInput.addEventListener('input', () => {
                if (autoPopulateSeoTopicCheckbox.checked) {
                    researchTopicInput.value = scenarioInput.value;
                }
            });


            researchProfilesSelect.addEventListener('change', (e) => {
                const selectedTopic = e.target.value;
                if (selectedTopic && researchProfiles[selectedTopic]) {
                    const profile = researchProfiles[selectedTopic];
                    currentResearchData = profile; // Set as current research
                    const keywords = profile.keywords ? profile.keywords.join(', ') : '';
                    const hooks = profile.descriptionHooks ? profile.descriptionHooks.join(' ') : '';
                    imageContextInput.value = `Keywords: ${keywords}\n\nHooks: ${hooks}`;
                } else {
                    currentResearchData = null; // Clear current research
                    imageContextInput.value = '';
                }
            });

            editorToolbar.addEventListener('click', (e) => {
                e.preventDefault();
                const button = e.target.closest('.edit-btn');
                if (!button) return;

                const tag = button.dataset.tag;
                const style = button.dataset.style || '';
                wrapSelectionWithTag(tag, style);
            });

            document.querySelectorAll('.export-option').forEach(input => input.addEventListener('change', () => { if (promptOutput.value) generatePrompt(); }));
            brushSizeInput.addEventListener('input', updateBrushSize);
            [fontFamilySelect, fontSizeSelect, fontColorInput].forEach(el => el.addEventListener('input', updateFontPreview));

            editorCanvas.addEventListener('mouseenter', (e) => { // Modified
                editorCanvas.classList.add('editing');
                customCursor.style.display = 'block';
                updateBrushSize(); // Ensure size is correct on enter
                customCursor.style.left = `${e.clientX}px`; // Position immediately
                customCursor.style.top = `${e.clientY}px`;
            });
            editorCanvas.addEventListener('mouseleave', () => { // Modified
                editorCanvas.classList.remove('editing');
                customCursor.style.display = 'none';
            });
            editorCanvas.addEventListener('mousemove', (e) => { // Modified
                if (!editorCanvas.classList.contains('editing')) return; // Ensure cursor is only shown inside
                customCursor.style.left = `${e.clientX}px`;
                customCursor.style.top = `${e.clientY}px`;
                draw(e);
            });
            editorCanvas.addEventListener('mousedown', (e) => { isDrawing = true; draw(e); });
            editorCanvas.addEventListener('mouseup', () => isDrawing = false);
            editorCanvas.addEventListener('touchend', () => isDrawing = false);

            clearMaskBtn.addEventListener('click', () => initializeEditor(originalImageBase64)); // This already resets filters
            copyPromptBtn.addEventListener('click', () => {
                const textToCopy = promptOutput.value;
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    copyPromptBtn.textContent = 'Copied!';
                    setTimeout(() => { copyPromptBtn.textContent = 'Copy'; }, 2000);
                } catch (err) { console.error('Fallback copy failed', err); }
                document.body.removeChild(textArea);
            });

            platformSelect.addEventListener('change', displayListingInputs);
            generateListingBtn.addEventListener('click', generateListing);
            researchSeoBtn.addEventListener('click', researchSEOTopic);

            // Add click handlers for download buttons
            downloadBtn1.addEventListener('click', (e) => {
                e.preventDefault(); // Prevent default link behavior
                triggerDownload(originalImageBase64, 'pod-image.png');
            });
            downloadBtn2.addEventListener('click', (e) => {
                e.preventDefault(); // Prevent default link behavior
                triggerDownload(originalImageBase64, 'pod-image-edited.png');
            });

            // Add filter listeners
            brightnessSlider.addEventListener('input', updateCanvasFilters);
            contrastSlider.addEventListener('input', updateCanvasFilters);
            saturationSlider.addEventListener('input', updateCanvasFilters);
            applyFiltersBtn.addEventListener('click', applyFilters);


            const initializeApp = () => {
                updateFontPreview();
                updateBrushSize();
                handleTypographyToggle();
                handleAutoFontToggle(); // Initial check
                handleAutoStyleSelect(); // Initial check
                populatePlatformSelector();
            };

            initializeApp();
        });
    </script>
</body>

</html>
