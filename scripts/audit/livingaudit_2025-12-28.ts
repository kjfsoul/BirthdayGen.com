// scripts/audit/livingaudit_2025-12-28.ts
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as crypto from 'node:crypto';

interface AuditConfig {
  projectName: string;
  rootDir: string;
  scanPatterns: string[];
  excludePatterns: string[];
  beadsPath: string;
  memoryPath: string;
}

interface FileManifest {
  path: string;
  hash: string;
  mtime: Date;
  ctime: Date;
  size: number;
  associatedTask?: string;
}

interface BeadsIssue {
  id: string;
  title: string;
  description: string;
  status: 'open' | 'closed' | 'in_progress';
  priority: number;
  issue_type: string;
  created_at: string;
  updated_at: string;
  closed_at?: string;
  labels?: string[];
  dependencies?: {
    issue_id: string;
    depends_on_id: string;
    type: string;
  }[];
}

interface ConflictDetection {
  type: 'VERSION' | 'OWNERSHIP' | 'LOGIC' | 'TIMING' | 'DEPENDENCY';
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  description: string;
  affectedFiles: string[];
  resolution?: string;
}

const DEFAULT_TEMPLATE = `# Living Audit Report
Last Audited: 1970-01-01

## Context
<!-- AUTOGENERATED_START:context -->
<!-- AUTOGENERATED_END:context -->

## Feature Matrix
<!-- AUTOGENERATED_START:featurematrix -->
<!-- AUTOGENERATED_END:featurematrix -->

## Immediate Tasks
<!-- AUTOGENERATED_START:immediatetasks -->
<!-- AUTOGENERATED_END:immediatetasks -->

## Weekly Tasks
<!-- AUTOGENERATED_START:weeklytasks -->
<!-- AUTOGENERATED_END:weeklytasks -->

## Blocked Tasks
<!-- AUTOGENERATED_START:blockedtasks -->
<!-- AUTOGENERATED_END:blockedtasks -->

## Memory Snapshots
<!-- AUTOGENERATED_START:memorysnapshots -->
<!-- AUTOGENERATED_END:memorysnapshots -->

## Metrics
<!-- AUTOGENERATED_START:metrics -->
<!-- AUTOGENERATED_END:metrics -->

## Blockers
<!-- AUTOGENERATED_START:blockers -->
<!-- AUTOGENERATED_END:blockers -->
`;

export class LivingAuditOrchestrator {
  private readonly config: AuditConfig;
  private readonly currentCycle: number;
  private manifest: FileManifest[] = [];
  private conflicts: ConflictDetection[] = [];

  constructor(config: AuditConfig) {
    this.config = config;
    this.currentCycle = this.loadLatestCycleNumber() + 1;
  }

  // Phase 1: Reconciliation - File Scan & Conflict Detection
  async runReconciliation(): Promise<void> {
    console.log(`[Audit Cycle ${this.currentCycle}] Phase 1: Reconciliation`);

    // 1.1 Scan file system (sorted by mtime)
    this.manifest = await this.scanFileSystem();

    // 1.2 Load previous manifest for comparison (stub/placeholder for real logic)
    const previousManifest = this.loadPreviousManifest();

    // 1.3 Detect conflicts
    this.conflicts = await this.detectConflicts(this.manifest, previousManifest);

    // 1.4 Integrate external sources (.beads, memory logs)
    await this.integrateBeadsTasks();
    await this.integrateMemoryLogs();

    console.log(`[Audit] Found ${this.manifest.length} files, ${this.conflicts.length} conflicts`);
  }

  // Scan file system using native Node.js recursive walk
  private async scanFileSystem(): Promise<FileManifest[]> {
    const files: FileManifest[] = [];

    try {
      this.walk(this.config.rootDir, (filePath) => {
        try {
          const relativePath = filePath.replace(this.config.rootDir, '');

          if (this.shouldExclude(relativePath)) return;

          const stats = fs.statSync(filePath);
          const content = fs.readFileSync(filePath, 'utf-8');
          const hash = crypto.createHash('sha256').update(content).digest('hex');

          files.push({
            path: relativePath,
            hash,
            mtime: stats.mtime,
            ctime: stats.ctime,
            size: stats.size
          });
        } catch (err) {
          console.warn(`[Audit] Failed to process file ${filePath}:`, err);
        }
      });

      // Sort by mtime descending (newest first)
      files.sort((a, b) => b.mtime.getTime() - a.mtime.getTime());

    } catch (error) {
      console.error('[Audit] File scan error', error);
    }

    return files;
  }

  // Recursive directory walker
  private walk(dir: string, callback: (path: string) => void): void {
    const items = fs.readdirSync(dir, { withFileTypes: true });

    for (const item of items) {
      const fullPath = path.join(dir, item.name);

      // Check exclusion on directory/file name first
      if (this.config.excludePatterns.some(pattern => item.name === pattern || fullPath.includes(pattern))) {
        continue;
      }

      if (item.isDirectory()) {
        this.walk(fullPath, callback);
      } else if (item.isFile()) {
        // Check extension
         const ext = path.extname(item.name);
         if (this.config.scanPatterns.includes(ext) || this.config.scanPatterns.includes('*')) {
             callback(fullPath);
         }
      }
    }
  }

  // Detect conflicts by comparing current vs previous state
  private async detectConflicts(
    current: FileManifest[],
    previous: FileManifest[]
  ): Promise<ConflictDetection[]> {
    const conflicts: ConflictDetection[] = [];

    // TYPE 1: VERSION CONFLICTS
    for (const currFile of current) {
      const prevFile = previous.find(f => f.path === currFile.path);

      if (prevFile && prevFile.hash !== currFile.hash && !currFile.associatedTask) {
        conflicts.push({
          type: 'VERSION',
          severity: 'HIGH',
          description: `File modified outside audit system: ${currFile.path}`,
          affectedFiles: [currFile.path]
        });
      }
    }

    // TYPE 2: TIMING CONFLICTS
    const completedTasks = await this.getCompletedTasks();
    for (const task of completedTasks) {
      const recentlyModified = current.filter(
        f => f.associatedTask === task.id && f.mtime > task.completedDate
      );

      if (recentlyModified.length > 0) {
        conflicts.push({
          type: 'TIMING',
          severity: 'MEDIUM',
          description: `Task ${task.id} marked complete but files still modified`,
          affectedFiles: recentlyModified.map(f => f.path)
        });
      }
    }

    // TYPE 3: LOGIC CONFLICTS
    for (const file of current) {
      // Example logic check
      if (file.path.includes('api/astrology/compatibility')) {
         try {
            const content = fs.readFileSync(path.join(this.config.rootDir, file.path), 'utf-8');
            if (content.includes('return 75')) {
                conflicts.push({
                    type: 'LOGIC',
                    severity: 'HIGH',
                    description: 'Hardcoded compatibility score detected',
                    affectedFiles: [file.path],
                    resolution: 'Implement Discepolo algorithm in T002'
                });
            }
         } catch (e) { /* ignore */ }
      }
    }

    return conflicts;
  }

  // Phase 2: Generate Living Audit Document (SSoT)
  async generateAuditDocument(): Promise<void> {
    console.log(`[Audit Cycle ${this.currentCycle}] Phase 2: Generate SSoT`);

    // Dynamic Template Loading
    let content = this.loadAuditTemplate();

    // Dynamic Header Update
    const today = new Date().toISOString().split('T')[0];
    const headerRegex = /Last Audited: \d{4}-\d{2}-\d{2}/;
    if (headerRegex.test(content)) {
        content = content.replace(headerRegex, `Last Audited: ${today}`);
    } else {
        // If missing, consider adding it
        content = `Last Audited: ${today}\n` + content;
    }

    // Replace auto-generated sections
    content = this.updateSection(content, 'context', await this.generateContextSection());
    content = this.updateSection(content, 'featurematrix', await this.generateFeatureMatrix());
    content = this.updateSection(content, 'immediatetasks', await this.generateImmediateTasks());
    content = this.updateSection(content, 'weeklytasks', await this.generateWeeklyTasks());
    content = this.updateSection(content, 'blockedtasks', await this.generateBlockedTasks());
    content = this.updateSection(content, 'memorysnapshots', await this.generateMemorySnapshots());
    content = this.updateSection(content, 'metrics', await this.generateMetrics());
    content = this.updateSection(content, 'blockers', await this.generateBlockers());

    // Write current audit document
    const auditDir = path.join(this.config.rootDir, '.audit');
    if (!fs.existsSync(auditDir)) fs.mkdirSync(auditDir, { recursive: true });

    const auditPath = path.join(auditDir, 'LIVING_AUDIT.md');
    try {
        fs.writeFileSync(auditPath, content);
    } catch (e) {
        console.error(`[Audit] Failed to write audit document: ${e}`);
    }

    // Create immutable snapshot
    const snapshotPath = path.join(
      auditDir,
      `AUDIT_CYCLE_${String(this.currentCycle).padStart(3, '0')}.md`
    );
    try {
        fs.writeFileSync(snapshotPath, content);
    } catch(e) {
        console.error(`[Audit] Failed to write snapshot: ${e}`);
    }

    // Log conflicts permanently
    if (this.conflicts.length > 0) {
      this.appendConflictsLog();
    }

    console.log(`[Audit] Generated ${auditPath}`);
  }

  private loadAuditTemplate(): string {
      const auditPath = path.join(this.config.rootDir, '.audit', 'LIVING_AUDIT.md');
      try {
          if (fs.existsSync(auditPath)) {
              return fs.readFileSync(auditPath, 'utf-8');
          }
      } catch (e) {
          console.warn(`[Audit] Could not read existing audit file, using default template. Error: ${e}`);
      }
      return DEFAULT_TEMPLATE;
  }

  // Update section between AUTOGENERATED markers
  private updateSection(content: string, sectionName: string, newContent: string): string {
    const startMarker = `<!-- AUTOGENERATED_START:${sectionName} -->`;
    const endMarker = `<!-- AUTOGENERATED_END:${sectionName} -->`;

    const startIdx = content.indexOf(startMarker);
    const endIdx = content.indexOf(endMarker);

    if (startIdx === -1 || endIdx === -1) {
      console.warn(`[Audit] Section markers not found: ${sectionName}. Returning original content.`);
      return content;
    }

    if (endIdx <= startIdx) {
        console.warn(`[Audit] Invalid marker positions for: ${sectionName}`);
        return content;
    }

    return (
      content.substring(0, startIdx + startMarker.length) +
      '\n' + newContent + '\n' +
      content.substring(endIdx)
    );
  }

  // Generate feature matrix from project state
  private async generateFeatureMatrix(): Promise<string> {
    const features = await this.loadFeatures();
    let table = [
      `| Feature ID | Name | Status | Action | Progress | Conflicts | Last Modified |`,
      `|------------|------|--------|--------|----------|-----------|---------------|`
    ];

    for (const feature of features) {
      // Determine Action
      let action = 'Maintain';
      if (feature.progress === 0 || feature.status.toLowerCase().includes('not started')) {
          action = 'Create';
      } else if (feature.progress < 100) {
          // Check for active bugs related to this feature's files
          // For now, heuristic: if status is "Incomplete", assume Enhance.
          // If we had file mapping, we could check for 'bug' issues on those files.
          // Let's use a simple heuristic based on status/progress for now.
          if (feature.status.toLowerCase().includes('bug') || feature.status.toLowerCase().includes('fix')) {
              action = 'Repair';
          } else {
              action = 'Enhance';
          }
      }

      // Check for conflicts
      const featureConflicts = this.conflicts.filter(c =>
        feature.files.some((f: string) => c.affectedFiles.includes(f))
      );
      const conflictStatus = featureConflicts.length > 0
        ? `**${featureConflicts.length} Conflicts**`
        : 'None';

      const lastMod = this.manifest
        .filter(f => feature.files.includes(f.path))
        .sort((a, b) => b.mtime.getTime() - a.mtime.getTime())[0]?.mtime
        .toISOString().split('T')[0] || 'N/A';

      table.push(
        `| ${feature.id} | ${feature.name} | ${feature.status} | ${action} | ${feature.progress}% | ${conflictStatus} | ${lastMod} |`
      );
    }

    return table.join('\n');
  }

  // Integrate Beads task tracking
  private async integrateBeadsTasks(): Promise<void> {
    const beadsPath = path.join(this.config.rootDir, this.config.beadsPath);
    if (!fs.existsSync(beadsPath)) return;

    try {
        const content = fs.readFileSync(beadsPath, 'utf-8');
        const issues = content.split('\n').filter(Boolean).map(line => {
             try { return JSON.parse(line); } catch(e) { return null; }
        }).filter(i => i !== null);

        const openTasks = issues.filter((i: any) => i.status === 'open').length;
        const closedTasks = issues.filter((i: any) => i.status === 'closed').length;

        console.log(`[Audit] Beads Integration: ${openTasks} open, ${closedTasks} closed`);

        // Link files to tasks
        for (const issue of issues) {
          if (issue.files) {
            for (const filePath of issue.files) {
              const manifestEntry = this.manifest.find(f => f.path === filePath);
              if (manifestEntry) {
                manifestEntry.associatedTask = issue.id;
              }
            }
          }
        }
    } catch (e) {
        console.error(`[Audit] Failed to integrate Beads tasks: ${e}`);
    }
  }

  // Phase 5: Generate status report
  async generateReport(): Promise<void> {
    const report = {
      cycle: this.currentCycle,
      timestamp: new Date().toISOString(),
      filesScanned: this.manifest.length,
      conflictsDetected: this.conflicts.length,
      criticalBlockers: this.conflicts.filter(c => c.severity === 'CRITICAL').length,
      summary: this.generateSummary()
    };

    console.log('[Audit] Report:', JSON.stringify(report, null, 2));

    // Send alerts if critical conflicts exist
    if (report.criticalBlockers > 0) {
      await this.sendCriticalAlert(report);
    }
  }

  // Send critical alert via n8n webhook
  private async sendCriticalAlert(report: any): Promise<void> {
    const webhookUrl = process.env.N8N_AUDIT_WEBHOOK_URL;
    if (!webhookUrl) return;

    try {
      await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          project: this.config.projectName,
          severity: 'CRITICAL',
          conflicts: this.conflicts.filter(c => c.severity === 'CRITICAL'),
          report
        })
      });
      console.log('[Audit] Critical alert sent');
    } catch (error) {
      console.error('[Audit] Failed to send alert', error);
    }
  }

  // Helpers
  private shouldExclude(filePath: string): boolean {
      // shouldExclude now relies on scanFileSystem to handle directory exclusion,
      // but we can double check file specific patterns here
      const filename = path.basename(filePath);
      return this.config.excludePatterns.some(p => filename === p || filePath.includes(p));
  }

  private loadPreviousManifest(): FileManifest[] { return []; }
  private loadLatestCycleNumber(): number { return 0; }
  private async getCompletedTasks(): Promise<any[]> {
      const issues = this.loadBeadsIssues();
      return issues.filter(i => i.status === 'closed').map(i => ({
        id: i.id,
        completedDate: new Date(i.closed_at || i.updated_at)
      }));
  }
  private async loadFeatures(): Promise<any[]> {
      const featuresPath = path.join(this.config.rootDir, 'docs', 'FEATURES.md');
      if (!fs.existsSync(featuresPath)) return [];

      const content = fs.readFileSync(featuresPath, 'utf-8');
      const features: any[] = [];

      // Regex to parse markdown table row: | 1 | Name | Route | 70% | ...
      // Adjust regex to match the specific format in FEATURES.md
      const tableRegex = /^\|\s*(\d+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|/;

      const lines = content.split('\n');
      let inTable = false;

      for (const line of lines) {
          if (line.includes('| # | Feature |')) {
              inTable = true;
              continue;
          }
          if (inTable && line.match(/^\|[-\s|]+$/)) { // Separator row
              continue;
          }
          if (inTable) {
              const match = line.match(tableRegex);
              if (match) {
                  const [_, id, name, route, completion, priority, effort, status] = match;

                  // Infer files from route
                  const files = [];
                  const cleanRoute = route.trim();
                  if (cleanRoute.startsWith('/')) {
                      // e.g. /generator -> src/app/generator
                      const routeName = cleanRoute.substring(1);
                      files.push(`src/app/${routeName}`);
                      files.push(`src/app/${routeName}/page.tsx`);
                  } else if (cleanRoute.toLowerCase().includes('backend')) {
                       files.push('supabase/functions');
                  }

                  features.push({
                      id: `F${id.trim().padStart(2, '0')}`,
                      name: name.trim(),
                      status: status.trim().replace(/[^a-zA-Z ]/g, ''), // Strip emojis if needed
                      progress: parseInt(completion.replace('%', '')) || 0,
                      files: files
                  });
              } else if (line.trim() === '') {
                  inTable = false;
              }
          }
      }
      return features;
  }

  private loadBeadsIssues(): BeadsIssue[] {
      const beadsPath = path.join(this.config.rootDir, this.config.beadsPath);
      if (!fs.existsSync(beadsPath)) return [];
      try {
          const content = fs.readFileSync(beadsPath, 'utf-8');
          return content.split('\n')
            .filter(Boolean)
            .map(line => {
                 try { return JSON.parse(line); } catch(e) { return null; }
            })
            .filter((i): i is BeadsIssue => i !== null);
      } catch (e) {
          console.error(`[Audit] Failed to load beads issues: ${e}`);
          return [];
      }
  }

  // Generating empty sections for now - can be expanded
  private async generateContextSection(): Promise<string> {
      const sessionInitPath = path.join(this.config.rootDir, 'session_init.md');
      if (fs.existsSync(sessionInitPath)) {
          return fs.readFileSync(sessionInitPath, 'utf-8');
      }
      return 'No active session initialization context found.';
  }
  private async generateImmediateTasks(): Promise<string> {
      const issues = this.loadBeadsIssues();
      // P0 and P1 are immediate
      const immediate = issues.filter(i =>
        (i.status === 'open' || i.status === 'in_progress') &&
        i.priority <= 1
      );

      if (immediate.length === 0) return 'No immediate (P0/P1) tasks.';

      let md = '| ID | Title | Priority | Status |\n|---|---|---|---|\n';
      immediate.forEach(i => {
          md += `| ${i.id} | ${i.title} | P${i.priority} | ${i.status} |\n`;
      });
      return md;
  }
  private async generateWeeklyTasks(): Promise<string> {
      const issues = this.loadBeadsIssues();
      // P2+ are weekly/backlog
      const weekly = issues.filter(i =>
        (i.status === 'open' || i.status === 'in_progress') &&
        i.priority > 1
      );

      if (weekly.length === 0) return 'No weekly (P2+) tasks.';

      let md = '| ID | Title | Priority | Status |\n|---|---|---|---|\n';
      weekly.forEach(i => {
          md += `| ${i.id} | ${i.title} | P${i.priority} | ${i.status} |\n`;
      });
      return md;
  }
  private async generateBlockedTasks(): Promise<string> {
      const issues = this.loadBeadsIssues();
      const openIssues = issues.filter(i => i.status !== 'closed');

      const blocked: BeadsIssue[] = [];
      const blockersMap = new Map<string, string[]>();

      for (const issue of openIssues) {
          if (!issue.dependencies) continue;

          const blockers = issue.dependencies
            .filter(d => d.type === 'blocks')
            .map(d => d.depends_on_id);

          const activeBlockers = blockers.filter(blockerId => {
              const blocker = issues.find(i => i.id === blockerId);
              return blocker && blocker.status !== 'closed';
          });

          if (activeBlockers.length > 0) {
              blocked.push(issue);
              blockersMap.set(issue.id, activeBlockers);
          }
      }

      if (blocked.length === 0) return 'No blocked tasks detected.';

      let md = '| Blocked Task | Blocked By |\n|---|---|\n';
      blocked.forEach(i => {
          const blockers = blockersMap.get(i.id) || [];
          md += `| ${i.title} (${i.id}) | ${blockers.join(', ')} |\n`;
      });
      return md;
  }
  private async generateMemorySnapshots(): Promise<string> {
      const memoryDir = path.join(this.config.rootDir, this.config.memoryPath);
      if (!fs.existsSync(memoryDir)) return 'Memory directory not found.';

      const files = fs.readdirSync(memoryDir)
         .map(f => ({ name: f, stat: fs.statSync(path.join(memoryDir, f)) }))
         .sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime())
         .slice(0, 10);

      let md = '| File | Modified | Size |\n|---|---|---|\n';
      files.forEach(f => {
          md += `| ${f.name} | ${f.stat.mtime.toISOString().split('T')[0]} | ${f.stat.size}b |\n`;
      });
      return md;
  }
  private async generateMetrics(): Promise<string> {
      const totalFiles = this.manifest.length;
      const extensions = this.manifest.reduce((acc, file) => {
          const ext = path.extname(file.path);
          acc[ext] = (acc[ext] || 0) + 1;
          return acc;
      }, {} as Record<string, number>);

      let md = `- **Total Files Scanned:** ${totalFiles}\n`;
      md += `- **Conflict Rate:** ${((this.conflicts.length / totalFiles) * 100).toFixed(1)}%\n`;
      md += `\n**Composition:**\n`;
      Object.entries(extensions)
        .sort((a, b) => b[1] - a[1])
        .forEach(([ext, count]) => {
            md += `- **${ext}**: ${count}\n`;
        });
      return md;
  }
  private async generateBlockers(): Promise<string> {
       // Critical system blockers from conflicts
       const critical = this.conflicts.filter(c => c.severity === 'CRITICAL');
       if (critical.length === 0) return 'No critical system conflicts detected.';

       let md = '| Severity | Description | Resolution |\n|---|---|---|\n';
       critical.forEach(c => {
           md += `| ${c.severity} | ${c.description} | ${c.resolution || 'Investigate'} |\n`;
       });
       return md;
  }
  private appendConflictsLog(): void { /* ... */ }
  private generateSummary(): string {
      return `Audit completed. Found ${this.conflicts.length} conflicts. Active tasks: ${this.loadBeadsIssues().filter(i => i.status !== 'closed').length}.`;
  }
  private async integrateMemoryLogs(): Promise<void> { /* ... */ }
}

// Main execution
const config: AuditConfig = {
  projectName: 'Mystic Arcana',
  rootDir: process.cwd(),
  scanPatterns: ['.ts', '.tsx', '.py', '.md', '.json', '.sql'], // Added .sql
  excludePatterns: ['node_modules', '.next', 'dist', '.git'],
  beadsPath: '.beads/issues.jsonl',
  memoryPath: 'memory/persistent'
};

const orchestrator = new LivingAuditOrchestrator(config);

void (async () => {
  try {
    await orchestrator.runReconciliation();
    await orchestrator.generateAuditDocument();
    await orchestrator.generateReport();
    console.log('[Audit] Cycle complete');
  } catch (error) {
    console.error('[Audit] Cycle failed', error);
    process.exit(1);
  }
})();
